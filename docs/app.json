[{"name": "app.py", "content": "##shiny run --reload --launch-browser GitHub/socits_abm_demo/socits_shiny/app.py\n\n##libraries\n\nimport random\nfrom random import randint\nimport numpy as np\nimport csv\nimport time\nimport os\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\nimport seaborn as sns\n\nimport networkx as nx\n\nfrom functools import partial\n\nimport scipy as sp\n\n##and the function files\n\nfrom agent_class import Agent\nfrom location_class import Location\n\nfrom general_functions import Generate_Location_Grid\nfrom general_functions import Generate_Corridor\nfrom general_functions import Generate_Floor_Corridor\nfrom general_functions import Generate_Two_Floor_School\nfrom general_functions import Generate_Two_Floor_School_Shut_Top_Floor\nfrom general_functions import Generate_Two_Floor_School_Shut_Bottom_Floor\n\nfrom general_functions import Update_Location_Graph\n\n#from plot_output_functions import Plot_Output_Shiny\n\nfrom run_single_model_function import Run_The_Model_Once\n\nfrom shiny.express import ui, input, render\nfrom shiny import reactive\n\n\nwith ui.sidebar():\n\n#    ui.input_slider(\"no_students\", \"No. students\", 1, 200, 100)\n    \n#    ui.input_slider(\"no_teachers\", \"No. teachers\", 1, 50, 10)\n    \n    ui.input_radio_buttons(\"stress_decay_level\", \"Deep breath effect\", choices=[\"Low\", \"High\"])\n    \n    ui.input_radio_buttons(\"prob_teacher_moving_level\", \"Staff in corridors\", choices=[\"Hardly ever\", \"Almost always\"])\n    \n    ui.input_checkbox(\"inc_science_perspective_input\", \"What scientists think\", False)\n    \n    ui.input_checkbox(\"inc_youth_perspective_input\", \"What young people think\", False)\n    \n    ui.input_checkbox(\"inc_walking_input\", \"Walking interviews\", True)\n    \n#    ui.input_checkbox(\"inc_walking_perspective_input\", \"Include walk persp.\", False)\n    \n #   ui.input_checkbox(\"inc_yais_perspective_input\", \"Include YAIs persp.\", False)\n    \n  #  ui.input_checkbox(\"inc_teacher_perspective_input\", \"Include teacher persp.\", False)\n    \n    ui.input_radio_buttons(\"output_type\", \"Output\", choices=[\"Stress\", \"Loneliness\"])\n    \n    ui.input_radio_buttons(\"plot_type\", \"Plot type\", choices=[\"Time\", \"Map\", \"Situation map\"])\n\n    \n@render.plot(alt=\"A histogram\")\n\ndef Socits_Model():\n\n    ##general variables\n\n    ##run the model code?\n\n    ##1=run the model before plotting\n\n    ##0=load data from the last run\n    \n    use_emp_networks=0\n\n    ##map size\n\n    ##map type options....\n\n    ##\"grid\" = standard grid\n    ##\"school\" = the school map\n\n    map_type=\"school\"\n\n    floor_width=10\n\n    floor_length=10\n\n    stair_case_width=5\n\n    corridor_width=1\n\n    ##time steps\n\n    no_time_steps=120\n\n    ##no. of different agent types\n\n    no_students=100#input.no_students()\n\n    no_teachers=10#input.no_teachers()\n\n    no_agents=no_students+no_teachers\n\n    no_bullies=0\n    \n    no_groups=30\n\n    ##parameters common to all perspectives\n\n    stress_decay_level=input.stress_decay_level()\n\n    stress_decay=0.3 ##how quickly stress decays\n\n    if stress_decay_level==\"Low\":\n\n        stress_decay=0.15 ##how quickly stress decays\n\n    prob_teacher_moving=0.2 ##the probability of a teacher moving around the school\n    \n    if input.prob_teacher_moving_level()==\"Almost always\":\n\n        prob_teacher_moving=0.8\n    \n    move_with_friends=0.5 ##should individuals try to move with friends?  1==Yes, 0==No\n\n    moving_times=[10, 40, 60, 80, 110]\n\n    lunch_times=[0, 1, 0, 1, 0]\n\n    mean_time_stress=-10 ##the mean of the normal distribution for the time stress\n\n    mean_room_stress=1\n    \n    toilet_prob=0.4 ##probability of any student going to the toilet at any one time\n\n    canteen_prob=0.8 ##probability of any student eating lunch in the canteen\n\n    prob_follow_group=0.9\n\n    ##parameters to include certain perspective (1=include)\n\n    inc_science_perspective=0\n    \n    inc_walking_perspective=0\n\n    inc_yais_perspective=0\n\n    inc_teacher_perspective=0\n\n    if input.inc_science_perspective_input()==1:\n\n        inc_science_perspective=1\n    \n    else:\n    \n        inc_science_perspective=0\n\n    if input.inc_youth_perspective_input()==1:\n\n        inc_walking_perspective=1\n        \n        inc_yais_perspective=1\n        \n        inc_teacher_perspective=1\n    \n    else:\n    \n        inc_walking_perspective=0\n        \n        inc_yais_perspective=0\n        \n        inc_teacher_perspective=0\n        \n    if input.inc_walking_input()==1:\n\n        inc_walking_perspective=1\n        \n    else:\n    \n        inc_walking_perspective=0\n        \n        \n        \n        \n\n\n#    if input.inc_walking_perspective_input()==1:\n\n #       inc_walking_perspective=1\n    \n  #  else:\n    \n#        inc_walking_perspective=0\n        \n #   if input.inc_yais_perspective_input()==1:\n\n  #      inc_yais_perspective=1\n    \n   # else:\n    \n    #    inc_yais_perspective=0\n        \n#    if input.inc_teacher_perspective_input()==1:\n\n #       inc_teacher_perspective=1\n    \n  #  else:\n    \n   #     inc_teacher_perspective=0\n\n\n    ##science model\n\n    ##triggers\n\n    status_threshold=1 ##theshold for the status difference before a negative interaction\n\n    stress_bully_scale=1\n\n    ##consequences\n\n    increase_in_stress_due_to_neg_int=1.2 ##change in stress due to a negative interaction\n\n    decrease_in_stress_due_to_pos_int=0.2 ##change in stress due to a positive interaction\n\n    rq_decrease_through_bullying=1 ##change in relationship quality due to a negative interaction\n\n    rq_increase_through_support=1.5 ##change in relationship quality due to a positive interaction\n\n    status_increase=1 ##increase in status if an individual interacts negatively\n\n    status_decrease=1 ##decrease in status if an individual receives a negative interaction\n\n    ##yai's model\n\n    ##triggers\n\n    crowded_threshold=2 ##number of others in a location before stress increases\n\n    ##consequences\n\n    crowded_stress=1 ##the amount by which stress increases due to crowdedness\n\n    journey_stress=1 ##stress increase if a journey is disrupted\n\n    ##walking interviews model\n\n    ##No additional parameters required\n\n    ##teachers model\n\n    ##triggers\n\n    no_classes=4 ##no. of different possible classes\n\n    class_prob_dist=[0.25,0.25,0.25,0.25] ##how these classes are distributed in the population\n\n    ##consequences\n\n    stress_through_class_interaction=1 ##stress increase due to negative interaction between students and teachers\n\n    ########################################################\n\n    ##Part C: run the model\n\n    ##the following line calls the function \"Run_The_Model_Once\" in the file \"run_single_model_function.py\" to run the model, and returns all of the agents information in each time step\n        \n    plot_type=\"0\"\n    \n    all_technical_inputs=[plot_type, map_type, floor_width, floor_length, stair_case_width, corridor_width, no_time_steps, no_students, no_teachers, no_bullies,inc_science_perspective, inc_walking_perspective, inc_yais_perspective, inc_teacher_perspective, no_classes, moving_times, move_with_friends, lunch_times, no_groups, class_prob_dist, use_emp_networks]\n\n    all_inputs_set_through_data=[toilet_prob, canteen_prob]\n\n    all_calibrated_inputs=[stress_decay, status_threshold, increase_in_stress_due_to_neg_int, decrease_in_stress_due_to_pos_int, rq_decrease_through_bullying,rq_increase_through_support, crowded_threshold, crowded_stress, journey_stress, stress_bully_scale, stress_through_class_interaction, prob_teacher_moving, status_increase, status_decrease, mean_time_stress, mean_room_stress, prob_follow_group]\n\n    all_outputs=Run_The_Model_Once(all_calibrated_inputs, all_inputs_set_through_data, all_technical_inputs)\n\n    all_agents=all_outputs[0]\n\n    all_locations=all_outputs[1]\n\n    ###########\n\n    ##save the model output\n\n    ##first generate an array which contains each agent's info at each timestep\n\n    sel_agent=0\n\n    model_output=np.hstack([np.zeros([no_time_steps,1]),all_agents[sel_agent].agent_info])\n\n    for sel_agent in np.arange(1,no_agents):\n\n        sel_agent_model_output=np.hstack([np.ones([no_time_steps,1])*sel_agent,all_agents[sel_agent].agent_info])\n\n        model_output=np.vstack([model_output,sel_agent_model_output])\n\n#    print(\"Model output\")\n\n#    print(model_output)\n\n        ##and write them to a file\n\n#        file_name=Path(__file__).parent/\"model_output_shiny.csv\"\n\n#        file_name=\"GitHub/socits_abm/model_output_shiny.csv\"\n\n #       no_values=len(model_output[:,0])\n\n  #      with open(file_name, 'w', encoding='UTF8',newline='') as f:\n\n   #         writer = csv.writer(f)\n            \n    #        for sol_value in np.arange(no_values): \n\n     #           writer.writerow(model_output[sol_value,:])\n\n#    if input.run_new()==\"No\":\n        \n #       model_output_file=open('GitHub/socits_abm/model_output_shiny.csv' %locals())\n #       model_output_tmp=csv.reader(model_output_file)\n  #      model_output=list(model_output_tmp)\n  #      model_output=np.array(model_output)\n#\n   #     model_output=model_output.astype(float)\n\n    #    print(\"Model output\")\n\n     #   print(model_output)\n        \n #       age_category=np.zeros(no_agents)\n    \n  #      if use_emp_networks==1:\n        \n   #         no_in_each_age=[171, 205]\n            \n    #    else:\n            \n      #      no_in_each_age_tmp=int((no_agents-no_teachers)/2)\n     #       \n       #     no_in_each_age=np.zeros(2).astype(int)\n            \n        #    no_in_each_age[0]=int(no_in_each_age_tmp)\n            \n         #   no_in_each_age[1]=int(no_in_each_age_tmp)\n        \n#        age_category[no_teachers:(no_in_each_age[0]+no_teachers)]=1\n        \n #       age_category[(no_in_each_age[0]+no_teachers+1):no_agents]=2\n        \n #       all_agents=[]\n\n  #      for sel_agent in np.arange(no_agents):\n\n   #         all_agents.append(Agent(sel_agent, no_time_steps, age_category))\n\n    #    for sel_agent in np.arange(no_agents):\n    \n     #       sel_agent_info_loc=np.where(model_output[:,0]==sel_agent)[0]\n            \n      #      sel_agent_info_all_cols=model_output[sel_agent_info_loc,:]\n            \n       #     sel_agent_info=sel_agent_info_all_cols[:,[1,2,3,4,5,6]]\n            \n        #    all_agents[sel_agent].agent_info=sel_agent_info\n            \n    \n    \n    ########\n    \n    ##plot_type.....\n\n    ##0 = animation\n\n    ##1 = single time step\n\n    ##3 = selected output\n\n    plot_type=\"3\"\n\n    sel_time_step=83#input.sel_time_step()\n\n    ##selected output.....\n\n    ##3 = stress\n\n    ##4 = loneliness\n\n    if input.output_type()==\"Stress\":\n\n        selected_output=3\n        \n    elif input.output_type()==\"Loneliness\":\n\n        selected_output=4\n\n    selected_output_name=\"Stress\"\n    #selected_output_name=\"Relationship quality\"\n\n    save_animation=\"No\"\n\n#    Plot_Output_Shiny(all_agents, floor_width, floor_length, stair_case_width, corridor_width, plot_type, selected_output, selected_output_name, map_type, save_animation, sel_time_step)\n\n    plot_type=input.plot_type()\n\n    if plot_type==\"Time\":\n\n        no_agents=len(all_agents) ##find the number of agents\n\n        no_time_steps=len(all_agents[0].agent_info[:,0]) ##and the number of time steps\n\n        all_agent_output=np.zeros([no_time_steps,no_agents]) ##initialise agent output for all agents\n\n        all_agent_types=np.zeros(no_agents) ##and record their types\n\n        for sel_agent in np.arange(no_agents): ##for each agent, assign the specific output to the output array\n\n            all_agent_output[:,sel_agent]=all_agents[sel_agent].agent_info[:,selected_output]\n            \n            all_agent_types[sel_agent]=all_agents[sel_agent].agent_info[0,2] ##and the types\n            \n\n        student_agents=np.where(all_agent_types==0)[0] ##find all the student agents\n\n    #        print(\"student_agents\")\n\n    #       print(student_agents)\n\n        #all_agent_output=all_agent_output[:,student_agents]\n\n        min_all_agent_output=np.min(np.mean(all_agent_output[:,student_agents],axis=0)) ##find the minimum mean output\n\n        max_all_agent_output=np.max(np.mean(all_agent_output[:,student_agents],axis=0)) ##and the maximum\n\n    #      print(\"min_agent_stress\")\n\n    #     print(min_all_agent_output)\n\n    #    print(\"max_agent_stress\")\n\n     #   print(max_all_agent_output)\n\n        sel_min_agent=np.where([np.mean(all_agent_output[:,student_agents],axis=0)==min_all_agent_output])[1][0] ##find which agent has the minimum\n\n        sel_max_agent=np.where([np.mean(all_agent_output[:,student_agents],axis=0)==max_all_agent_output])[1][0] ##and the maximum\n\n      #  print(\"min agent = \",sel_min_agent)\n\n       # print(\"max agent = \",sel_max_agent)\n\n        perm_agents=np.random.permutation(student_agents) ##randomly permute the agents so we can select some random ones\n\n        no_students=len(student_agents)\n        \n        if no_students<4: ##if there is a small number of students, plot them all\n        \n            sel_agents=perm_agents\n\n        else: ##if not, select two at random and the smallest and largest output agents\n\n            sel_agents=np.hstack([perm_agents[0:2],sel_min_agent,sel_max_agent])\n\n    #        print(\"sel_agents\")\n\n    #       print(sel_agents)\n\n        #print(\"all_agent_output\")\n\n        #print(all_agent_output)\n        \n        ##plot the output across time\n        \n        fig, ax = plt.subplots()\n\n        for plot_agent in sel_agents: ##plot each agent output\n\n            ax.plot(np.arange(no_time_steps), all_agent_output[:,plot_agent])\n\n        ax.set_xlabel(\"Time\")\n\n        ax.set_ylabel(selected_output_name)\n        \n        plt.title(f\"Change over time for four students at {no_time_steps} time points in the school day\", fontsize=20)\n    \n    ##display it and save it\n    \n    if plot_type==\"Map\":\n    \n        no_agents=len(all_agents) ##find the number of agents\n\n        no_time_steps=len(all_agents[0].agent_info[:,0]) ##and the number of time steps\n\n        all_agent_output=np.zeros([no_time_steps,no_agents]) ##initialise agent output for all agents\n\n        all_agent_types=np.zeros(no_agents) ##and record their types\n\n        for sel_agent in np.arange(no_agents): ##for each agent, assign the specific output to the output array\n\n            all_agent_output[:,sel_agent]=all_agents[sel_agent].agent_info[:,selected_output]\n            \n            all_agent_types[sel_agent]=all_agents[sel_agent].agent_info[0,2] ##and the types\n            \n        print(\"All agent output\")\n        \n        print(all_agent_output)\n            \n        max_output=np.max(all_agent_output) ##find the maximum output across all agents, to be scaled for later\n\n        min_output=np.min(all_agent_output)\n\n        print(\"max_output\")\n\n        print(max_output)\n        \n        ##and then scale the agent output so it is between 0 and 1\n        \n        all_agent_output_scaled=(all_agent_output-min_output)/(max_output-min_output)\n\n        print(\"All agent output scaled\")\n        \n        print(all_agent_output_scaled)\n\n        ##initialise the output plot\n\n        fig, ax = plt.subplots()\n\n        ##generate a scatter for all agents locations\n\n        current_agent_locations=np.zeros([no_agents,4]) ##initialise the agent information array for this time step\n\n        poss_colours=np.array(['b','r']) ##initialise the possible colours\n        \n        for sel_agent in np.arange(no_agents):\n\n            current_agent_locations[sel_agent,[0,1]]=all_agents[sel_agent].agent_info[sel_time_step,[0,1]]\n\n        current_agent_locations[:,2]=all_agent_output_scaled[sel_time_step,:]\n        \n        current_agent_locations[:,3]=all_agent_types\n\n        print(\"Current agent locations\")\n\n        print(current_agent_locations)\n        \n        z=current_agent_locations[:,2]#.astype(int) ##and the value of the output of interest\n\n        ##create a matrix to generate a colour of each agent\n\n        colour_matrix=np.zeros([no_agents,4]) \n\n        reds=z\n\n        blues=1-z\n\n        greens=current_agent_locations[:,3]/2\n\n        alpha=np.ones(no_agents)\n\n        colour_matrix[:,0]=reds\n\n        colour_matrix[:,1]=greens\n\n        colour_matrix[:,2]=blues\n\n        colour_matrix[:,3]=alpha\n\n        print(\"colours\")\n\n        print(colour_matrix)\n\n\n#        scat=ax.scatter(all_agents[0].agent_info[0,0], all_agents[0].agent_info[0,1], c=[[current_agent_locations[0,2],0,0,1]], s=30) ##plot the initial scatter plot\n\n        scat=ax.scatter(current_agent_locations[:,0], current_agent_locations[:,1], c=colour_matrix, s=30) ##plot the initial scatter plot\n\n        #########################################\n        \n        if map_type==\"grid\":\n        \n            ##grid walls\n\n            for sel_grid in np.arange(floor_width+1):\n\n                ax.plot([sel_grid-0.5,sel_grid-0.5],[-0.5,floor_length+1.5],color='k',linewidth=2)\n                \n            for sel_grid in np.arange(floor_length+2):\n\n                ax.plot([-0.5,floor_width+1.5],[sel_grid-0.5,sel_grid-0.5],color='k',linewidth=2)\n        \n        ##########\n\n            ax.set(xlim=[-0.5, floor_length-0.5], ylim=[-0.5, floor_width-0.5])\n\n        if map_type==\"school\":        \n        \n            ##plot the school map\n\n            ##plot the ground floor\n\n            initial_floor_wall=0\n\n            left_wall=initial_floor_wall+np.round(floor_width/2)-np.round(corridor_width/2)\n\n            right_wall=initial_floor_wall+np.round(floor_width/2)+np.floor(corridor_width/2)+1\n\n            ##lower classroom wall\n                \n            ax.plot([initial_floor_wall-0.5,initial_floor_wall+floor_width-0.5],[0.5,0.5],color='k',linewidth=2)\n\n            ##upper classroom wall\n                \n            ax.plot([initial_floor_wall-0.5,initial_floor_wall+floor_width-0.5],[floor_length-1.5,floor_length-1.5],color='k',linewidth=2)\n\n            ##classroom walls\n\n            for sel_grid in np.arange(initial_floor_wall,initial_floor_wall+floor_width+1):\n\n                ax.plot([sel_grid-0.5,sel_grid-0.5],[-0.5,0.5],color='k',linewidth=2)\n                \n                ax.plot([sel_grid-0.5,sel_grid-0.5],[floor_length-1.5,floor_length-0.5],color='k',linewidth=2)\n            \n            ##left top corridor wall\n                \n            ax.plot([initial_floor_wall-0.5,left_wall-1.5],[floor_length-3.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##left bottom corridor wall\n            \n            ax.plot([initial_floor_wall-0.5,left_wall-1.5],[2.5,2.5],color='k',linewidth=2)\n\n            ##right top corridor wall\n\n            ax.plot([right_wall,initial_floor_wall+floor_width-0.5],[floor_length-3.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##right bottom corridor wall\n\n            ax.plot([right_wall,initial_floor_wall+floor_width-0.5],[2.5,2.5],color='k',linewidth=2)\n\n            ##corridor right wall\n\n            ax.plot([right_wall,right_wall],[2.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##corridor left wall\n\n            ax.plot([left_wall-1.5,left_wall-1.5],[2.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##########################\n            \n            ##plot the upper floor\n\n            initial_floor_wall=floor_width+stair_case_width\n\n            left_wall=initial_floor_wall+np.round(floor_width/2)-np.round(corridor_width/2)\n\n            right_wall=initial_floor_wall+np.round(floor_width/2)+np.floor(corridor_width/2)+1\n\n            ##lower classroom wall\n                \n            ax.plot([initial_floor_wall-0.5,initial_floor_wall+floor_width-0.5],[0.5,0.5],color='k',linewidth=2)\n\n            ##upper classroom wall\n                \n            ax.plot([initial_floor_wall-0.5,initial_floor_wall+floor_width-0.5],[floor_length-1.5,floor_length-1.5],color='k',linewidth=2)\n\n            ##classroom walls\n\n            for sel_grid in np.arange(initial_floor_wall,initial_floor_wall+floor_width+1):\n\n                ax.plot([sel_grid-0.5,sel_grid-0.5],[-0.5,0.5],color='k',linewidth=2)\n                \n                ax.plot([sel_grid-0.5,sel_grid-0.5],[floor_length-1.5,floor_length-0.5],color='k',linewidth=2)\n            \n            ##left top corridor wall\n                \n            ax.plot([initial_floor_wall-0.5,left_wall-1.5],[floor_length-3.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##left bottom corridor wall\n            \n            ax.plot([initial_floor_wall-0.5,left_wall-1.5],[2.5,2.5],color='k',linewidth=2)\n\n            ##right top corridor wall\n\n            ax.plot([right_wall,initial_floor_wall+floor_width-0.5],[floor_length-3.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##right bottom corridor wall\n\n            ax.plot([right_wall,initial_floor_wall+floor_width-0.5],[2.5,2.5],color='k',linewidth=2)\n\n            ##corridor right wall\n\n            ax.plot([right_wall,right_wall],[2.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##corridor left wall\n\n            ax.plot([left_wall-1.5,left_wall-1.5],[2.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##########\n            \n            ##plot the staircase\n            \n            staircase_beginning=floor_width\n            \n            staircase_end=staircase_beginning+stair_case_width\n            \n            ##top staircase upper wall\n            \n            ax.plot([staircase_beginning-0.5,staircase_end-0.5],[floor_length-1.5,floor_length-1.5],color='k',linewidth=2)\n            \n            ##top staircase lower wall\n            \n            ax.plot([staircase_beginning-0.5,staircase_end-0.5],[floor_length-3.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##bottom staircase upper wall\n            \n            ax.plot([staircase_beginning-0.5,staircase_end-0.5],[2.5,2.5],color='k',linewidth=2)\n            \n            ##bottom staircase lower wall\n            \n            ax.plot([staircase_beginning-0.5,staircase_end-0.5],[0.5,0.5],color='k',linewidth=2)\n            \n            ##and add some stairs\n\n            for sel_grid in np.arange(staircase_beginning+0.5,staircase_end,0.25):\n\n                ax.plot([sel_grid-0.5,sel_grid-0.5],[0.5,2.5],color='k',linewidth=2)\n                \n                ax.plot([sel_grid-0.5,sel_grid-0.5],[floor_length-3.5,floor_length-1.5],color='k',linewidth=2)\n            \n            ##########\n\n            ax.set(xlim=[-0.5, floor_width*2+stair_case_width-0.5], ylim=[-0.5, floor_length-0.5])\n        \n        ##and animate the output\n        \n        plt.title(f\"Map of the school at time point {sel_time_step}\", fontsize=20)\n\n        plt.xticks([])\n        plt.yticks([])\n        \n        \n    if plot_type==\"Heat\":\n    \n        no_agents=len(all_agents) ##find the number of agents\n\n        no_time_steps=len(all_agents[0].agent_info[:,0]) ##and the number of time steps\n\n        all_agent_output=np.zeros([no_time_steps,no_agents]) ##initialise agent output for all agents\n\n        all_agent_types=np.zeros(no_agents) ##and record their types\n\n        for sel_agent in np.arange(no_agents): ##for each agent, assign the specific output to the output array\n\n            all_agent_output[:,sel_agent]=all_agents[sel_agent].agent_info[:,selected_output]\n            \n            all_agent_types[sel_agent]=all_agents[sel_agent].agent_info[0,2] ##and the types\n            \n        print(\"All agent output\")\n        \n        print(all_agent_output)\n            \n        max_output=np.max(all_agent_output) ##find the maximum output across all agents, to be scaled for later\n\n        min_output=np.min(all_agent_output)\n\n        print(\"max_output\")\n\n        print(max_output)\n        \n        ##and then scale the agent output so it is between 0 and 1\n        \n        all_agent_output_scaled=(all_agent_output-min_output)/(max_output-min_output)\n\n        print(\"All agent output scaled\")\n        \n        print(all_agent_output_scaled)\n\n        ##initialise the output plot\n\n        fig, ax = plt.subplots()\n\n        ##generate a scatter for all agents locations\n\n        current_agent_locations=np.zeros([no_agents,4]) ##initialise the agent information array for this time step\n\n        poss_colours=np.array(['b','r']) ##initialise the possible colours\n        \n        for sel_time_step in np.arange(no_time_steps):\n        \n            for sel_agent in np.arange(no_agents):\n\n                current_agent_locations[sel_agent,[0,1]]=all_agents[sel_agent].agent_info[sel_time_step,[0,1]]\n\n            current_agent_locations[:,2]=all_agent_output_scaled[sel_time_step,:]\n            \n            current_agent_locations[:,3]=all_agent_types\n\n            print(\"Current agent locations\")\n\n            print(current_agent_locations)\n            \n            z=current_agent_locations[:,2]#.astype(int) ##and the value of the output of interest\n\n            ##create a matrix to generate a colour of each agent\n\n            colour_matrix=np.zeros([no_agents,4]) \n\n            reds=z\n\n            blues=1-z\n\n            greens=current_agent_locations[:,3]/2\n\n            alpha=np.ones(no_agents)\n\n            colour_matrix[:,0]=reds\n\n            colour_matrix[:,1]=greens\n\n            colour_matrix[:,2]=blues\n\n            colour_matrix[:,3]=alpha\n\n            print(\"colours\")\n\n            print(colour_matrix)\n\n\n    #        scat=ax.scatter(all_agents[0].agent_info[0,0], all_agents[0].agent_info[0,1], c=[[current_agent_locations[0,2],0,0,1]], s=30) ##plot the initial scatter plot\n\n            scat=ax.scatter(current_agent_locations[:,0], current_agent_locations[:,1], c=colour_matrix, s=10) ##plot the initial scatter plot\n\n        #########################################\n        \n        if map_type==\"grid\":\n        \n            ##grid walls\n\n            for sel_grid in np.arange(floor_width+1):\n\n                ax.plot([sel_grid-0.5,sel_grid-0.5],[-0.5,floor_length+1.5],color='k',linewidth=2)\n                \n            for sel_grid in np.arange(floor_length+2):\n\n                ax.plot([-0.5,floor_width+1.5],[sel_grid-0.5,sel_grid-0.5],color='k',linewidth=2)\n        \n        ##########\n\n            ax.set(xlim=[-0.5, floor_length-0.5], ylim=[-0.5, floor_width-0.5])\n\n        if map_type==\"school\":        \n        \n            ##plot the school map\n\n            ##plot the ground floor\n\n            initial_floor_wall=0\n\n            left_wall=initial_floor_wall+np.round(floor_width/2)-np.round(corridor_width/2)\n\n            right_wall=initial_floor_wall+np.round(floor_width/2)+np.floor(corridor_width/2)+1\n\n            ##lower classroom wall\n                \n            ax.plot([initial_floor_wall-0.5,initial_floor_wall+floor_width-0.5],[0.5,0.5],color='k',linewidth=2)\n\n            ##upper classroom wall\n                \n            ax.plot([initial_floor_wall-0.5,initial_floor_wall+floor_width-0.5],[floor_length-1.5,floor_length-1.5],color='k',linewidth=2)\n\n            ##classroom walls\n\n            for sel_grid in np.arange(initial_floor_wall,initial_floor_wall+floor_width+1):\n\n                ax.plot([sel_grid-0.5,sel_grid-0.5],[-0.5,0.5],color='k',linewidth=2)\n                \n                ax.plot([sel_grid-0.5,sel_grid-0.5],[floor_length-1.5,floor_length-0.5],color='k',linewidth=2)\n            \n            ##left top corridor wall\n                \n            ax.plot([initial_floor_wall-0.5,left_wall-1.5],[floor_length-3.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##left bottom corridor wall\n            \n            ax.plot([initial_floor_wall-0.5,left_wall-1.5],[2.5,2.5],color='k',linewidth=2)\n\n            ##right top corridor wall\n\n            ax.plot([right_wall,initial_floor_wall+floor_width-0.5],[floor_length-3.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##right bottom corridor wall\n\n            ax.plot([right_wall,initial_floor_wall+floor_width-0.5],[2.5,2.5],color='k',linewidth=2)\n\n            ##corridor right wall\n\n            ax.plot([right_wall,right_wall],[2.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##corridor left wall\n\n            ax.plot([left_wall-1.5,left_wall-1.5],[2.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##########################\n            \n            ##plot the upper floor\n\n            initial_floor_wall=floor_width+stair_case_width\n\n            left_wall=initial_floor_wall+np.round(floor_width/2)-np.round(corridor_width/2)\n\n            right_wall=initial_floor_wall+np.round(floor_width/2)+np.floor(corridor_width/2)+1\n\n            ##lower classroom wall\n                \n            ax.plot([initial_floor_wall-0.5,initial_floor_wall+floor_width-0.5],[0.5,0.5],color='k',linewidth=2)\n\n            ##upper classroom wall\n                \n            ax.plot([initial_floor_wall-0.5,initial_floor_wall+floor_width-0.5],[floor_length-1.5,floor_length-1.5],color='k',linewidth=2)\n\n            ##classroom walls\n\n            for sel_grid in np.arange(initial_floor_wall,initial_floor_wall+floor_width+1):\n\n                ax.plot([sel_grid-0.5,sel_grid-0.5],[-0.5,0.5],color='k',linewidth=2)\n                \n                ax.plot([sel_grid-0.5,sel_grid-0.5],[floor_length-1.5,floor_length-0.5],color='k',linewidth=2)\n            \n            ##left top corridor wall\n                \n            ax.plot([initial_floor_wall-0.5,left_wall-1.5],[floor_length-3.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##left bottom corridor wall\n            \n            ax.plot([initial_floor_wall-0.5,left_wall-1.5],[2.5,2.5],color='k',linewidth=2)\n\n            ##right top corridor wall\n\n            ax.plot([right_wall,initial_floor_wall+floor_width-0.5],[floor_length-3.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##right bottom corridor wall\n\n            ax.plot([right_wall,initial_floor_wall+floor_width-0.5],[2.5,2.5],color='k',linewidth=2)\n\n            ##corridor right wall\n\n            ax.plot([right_wall,right_wall],[2.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##corridor left wall\n\n            ax.plot([left_wall-1.5,left_wall-1.5],[2.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##########\n            \n            ##plot the staircase\n            \n            staircase_beginning=floor_width\n            \n            staircase_end=staircase_beginning+stair_case_width\n            \n            ##top staircase upper wall\n            \n            ax.plot([staircase_beginning-0.5,staircase_end-0.5],[floor_length-1.5,floor_length-1.5],color='k',linewidth=2)\n            \n            ##top staircase lower wall\n            \n            ax.plot([staircase_beginning-0.5,staircase_end-0.5],[floor_length-3.5,floor_length-3.5],color='k',linewidth=2)\n            \n            ##bottom staircase upper wall\n            \n            ax.plot([staircase_beginning-0.5,staircase_end-0.5],[2.5,2.5],color='k',linewidth=2)\n            \n            ##bottom staircase lower wall\n            \n            ax.plot([staircase_beginning-0.5,staircase_end-0.5],[0.5,0.5],color='k',linewidth=2)\n            \n            ##and add some stairs\n\n            for sel_grid in np.arange(staircase_beginning+0.5,staircase_end,0.25):\n\n                ax.plot([sel_grid-0.5,sel_grid-0.5],[0.5,2.5],color='k',linewidth=2)\n                \n                ax.plot([sel_grid-0.5,sel_grid-0.5],[floor_length-3.5,floor_length-1.5],color='k',linewidth=2)\n            \n            ##########\n\n            ax.set(xlim=[-0.5, floor_width*2+stair_case_width-0.5], ylim=[-0.5, floor_length-0.5])\n        \n        ##and animate the output\n\n        plt.xticks([])\n        plt.yticks([])\n\n    if plot_type==\"Situation map\": ##plot the SOCITS squares from the model\n        \n        no_agents=len(all_agents) ##find the number of agents\n        \n        no_locations=len(all_locations)\n\n        no_time_steps=len(all_agents[0].agent_info[:,0]) ##and the number of time steps\n\n        all_SAM2_output=np.zeros([no_agents, 4]) ##initialise agent output for all agents\n        \n        all_SAM2_count=np.ones([no_agents, 4]) ##initialise how many time steps this data is for\n        \n        poss_classrooms=all_agents[0].all_classrooms\n        \n        poss_toilets=all_agents[0].all_toilets\n        \n        poss_canteen=all_agents[0].all_canteens\n        \n#        print(\"poss_classrooms\")\n        \n #       print(poss_classrooms)\n        \n  #      print(\"poss_toilets\")\n        \n   #     print(poss_toilets)\n        \n    #    print(\"poss_canteen\")\n        \n     #   print(poss_canteen)\n        \n        all_non_corridors=np.hstack([poss_classrooms, poss_toilets, poss_canteen])\n        \n      #  print(\"all_non_corridors\")\n        \n       # print(all_non_corridors)\n\n        for sel_agent in np.arange(no_agents): ##for each agent, assign the specific output to the output array\n\n            sel_agent_info=all_agents[sel_agent].agent_info\n            \n            for time_step in np.arange(no_time_steps):\n                \n                agent_loc=int(sel_agent_info[time_step, 8])-1\n                \n        #        print(\"agent_loc = \",agent_loc)\n                \n                assigned_loc=0\n                \n                is_non_corridor=np.isin(agent_loc, all_non_corridors)\n                \n                if is_non_corridor==1:\n                    \n                    is_class=np.isin(agent_loc, poss_classrooms)\n                    \n                    is_canteen=np.isin(agent_loc, poss_canteen)\n                    \n                    is_toilet=np.isin(agent_loc, poss_toilets)\n                    \n                    if is_class==1:\n                    \n                        assigned_loc=1\n                        \n                    if is_toilet==1:\n                        \n                        assigned_loc=3\n                        \n                    if is_canteen==1:\n                        \n                        assigned_loc=2\n                        \n                    \n                \n#                print(\"is_non_corridor = \",is_non_corridor)\n                \n                #print(\"agent_loc = \",agent_loc)\n                \n         #       print(\"assigned_loc = \",assigned_loc)\n                \n                agent_output=sel_agent_info[time_step, selected_output]\n                \n                all_SAM2_output[sel_agent, assigned_loc]=all_SAM2_output[sel_agent, assigned_loc]+agent_output\n                \n                all_SAM2_count[sel_agent, assigned_loc]=all_SAM2_count[sel_agent, assigned_loc]+1\n        \n        \n#        print(\"All agent output SAM2\")\n        \n #       print(all_SAM2_output)\n        \n        all_scaled_SAM2_output=all_SAM2_output/all_SAM2_count\n        \n        max_measure=np.max(all_scaled_SAM2_output)\n        \n        min_measure=0\n        \n        nonzeros=np.nonzero(all_scaled_SAM2_output)\n        \n        if nonzeros[0].size!=0:\n        \n            min_measure=np.min(all_scaled_SAM2_output[np.nonzero(all_scaled_SAM2_output)])\n        \n  #      print(\"min_measure = \",min_measure)\n        \n        for sel_agent in np.arange(no_agents):\n            \n            for sel_loc in np.arange(4):\n                \n                all_scaled_SAM2_output_tmp=all_scaled_SAM2_output[sel_agent, sel_loc]\n                \n                if all_scaled_SAM2_output_tmp==0:\n                    \n                    all_scaled_SAM2_output[sel_agent, sel_loc]=min_measure+(max_measure-min_measure)/2\n                    \n                    \n\n#        print(\"All agent output output\")\n        \n #       print(all_scaled_SAM2_output)\n\n        all_scaled_SAM2_output=np.transpose(all_scaled_SAM2_output)\n        \n        ##now we want to eliminate all locations where nothing ever happens\n        \n        total_situation_count=np.sum(all_SAM2_count,axis=1)\n                \n        fig, ax = plt.subplots()\n\n        ax = sns.heatmap(all_scaled_SAM2_output, linewidth=0.5, cmap=\"coolwarm\")\n        \n        sns.color_palette(\"coolwarm\", as_cmap=True)\n\n        ax.set_ylabel(\"Location ID\")\n\n        ax.set_xlabel(\"Agent\")\n        \n        plt.title(\"Measure in each situation\", fontsize=20)\n        \n        ##display it and save it\n        \n        plt.yticks([0.5, 1.5, 2.5, 3.5], ['Corridor', 'Class', 'Canteen', 'Toilet'], rotation=20)  # Set text labels and properties.\n\n        plt.xticks([])\n\n#        plt.show()\n        \n #       plt.close()", "type": "text"}, {"name": "agent_class.py", "content": "##Part A: load in the libraries and functions for running the code\n\n##libraries\n\nimport random\nfrom random import randint\nimport numpy as np\nimport csv\nimport time\nimport os\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\nimport networkx as nx\n\nfrom functools import partial\n\nimport scipy as sp\n\n##and the function files\n\n########################################################\n\n##the following code defines the agent class, and all functions included involving the agent (calculating stress etc.)\n\nclass Agent():\n\n    ##this function initialises all the values for the agent\n\n    def __init__(self,agent_id, no_time_steps, age_category):\n\n        self.agent_id=agent_id\n        \n        self.agent_info=np.zeros([no_time_steps,9])\n        \n        ####\n        \n        ##initialise the age\n        \n        self.age=age_category[agent_id]\n        \n        ####\n        \n        ##location/movement values\n        \n        self.current_position=0\n\n        self.current_location=0\n        \n        self.goal_j=np.random.permutation([0,9])[0]\n\n        self.goal_i=np.random.randint(10)\n\n        self.goal_coord=[self.goal_i,self.goal_j]\n\n        self.goal_location=10*self.goal_i+self.goal_j\n        \n        self.journey_time=0\n        \n        self.go_to_toilet=0\n        \n        self.movement_group=0\n        \n        self.group_goals=0\n        \n        #####\n        \n        ##stress/loneliness values\n       \n        self.agent_class=0\n\n        self.ideal_goal_length=0\n\n        self.stress=0\n\n        self.base_stress=0\n\n        self.location_stress=0\n\n        self.time_stress=0\n        \n        self.status=np.random.random()\n        \n        self.pos_deg=0\n        \n        self.neg_deg=0\n        \n        ####\n\n        ##interaction variables\n\n        self.neg_int_prov=0\n\n        self.neg_int_rec=0\n\n        self.bullying=-1\n\n        self.bullied_by=-1\n\n        self.pos_int_prov=0\n\n        self.pos_int_rec=0\n\n        self.supporting=-1\n\n        self.supported_by=-1\n        \n        self.neg_class_int_prov=0\n\n        self.neg_class_int_rec=0\n\n        self.bullied_by_class=-1\n\n        ####\n\n        ##initial loneliness variables\n\n        self.rq=0\n\n        self.all_rq=0\n        \n        ######\n        \n        ##initial location variables\n        \n        self.available_locations=0\n        \n        self.all_classrooms=0\n        \n        self.all_toilets=0\n        \n        self.all_canteens=0\n        \n        self.all_staffrooms=0\n        \n    ##################################\n    \n    ##this function tells the agent which locations are classrooms\n    \n    ##Function: Record_All_Classrooms\n    \n    ##Inputs: all locations\n    \n    ##Outputs: A vector of all locations which are classrooms\n    \n    ##What it does\n    \n    ##This function looks at each location in turn, and if it is a classroom adds this to a vector for the agent to refer to each time they set a new goal.\n        \n    def Record_All_Location_Types(self,all_locations):\n    \n        no_locations=len(all_locations)\n        \n        all_poss_locations=[]\n\n        poss_classrooms=[] ##initialise an empty classroom vector\n        \n        poss_toilets=[]\n        \n        poss_canteen=[]\n        \n        poss_staffroom=[]\n        \n        for sel_location in np.arange(no_locations): ##checking through each location....\n\n            available_location=all_locations[sel_location].possible_location\n            \n            if available_location==1: ##if the location is a classroom, add it to the vector\n            \n                all_poss_locations=np.hstack([all_poss_locations,sel_location])\n\n\n            ###\n\n            classroom_location=all_locations[sel_location].is_classroom\n            \n            if classroom_location==1: ##if the location is a classroom, add it to the vector\n            \n                agent_year=self.age\n            \n                if agent_year==0:\n                \n                    poss_classrooms=np.hstack([poss_classrooms,sel_location])\n            \n                else:\n            \n                    room_year=all_locations[sel_location].classroom_year\n                \n                    if room_year==agent_year:\n                \n                        poss_classrooms=np.hstack([poss_classrooms,sel_location])\n                \n            ###\n                \n            toilet_location=all_locations[sel_location].is_toilet\n            \n            if toilet_location==1: ##if the location is a classroom, add it to the vector\n            \n                poss_toilets=np.hstack([poss_toilets,sel_location])\n            \n            ####\n            \n            canteen_location=all_locations[sel_location].is_canteen\n            \n            if canteen_location==1: ##if the location is a classroom, add it to the vector\n            \n                poss_canteen=np.hstack([poss_canteen,sel_location])\n                \n            ####\n                \n            staffroom_location=all_locations[sel_location].is_staff_room\n            \n            if staffroom_location==1: ##if the location is a classroom, add it to the vector\n            \n                poss_staffroom=np.hstack([poss_staffroom,sel_location])\n\n        self.all_classrooms=poss_classrooms ##and save the vector\n        \n        self.all_toilets=poss_toilets ##and save the vector\n        \n        self.all_canteens=poss_canteen ##and save the vector\n        \n        self.all_staffrooms=poss_staffroom ##and save the vector\n\n        self.available_locations=all_poss_locations\n\n#        print(\"self.all_classrooms\")\n\n #       print(self.all_classrooms)\n        \n  #      print(\"self.all_toilets\")\n        \n   #     print(self.all_toilets)\n        \n    #    print(\"self.all_canteens\")\n        \n     #   print(self.all_canteens)\n        \n      #  print(\"self.all_staffrooms\")\n       # print(self.all_staffrooms)\n        \n\n    ##################################\n    \n    ##this function initialises the location of the agent\n    \n    ##Function: Initialise_Location\n    \n    ##Inputs: all locations; the classrooms assigned to each teacher\n    \n    ##Outputs: The initial location of our agent\n    \n    ##What it does\n    \n    ##If the agent is a student, then they are randomly assigned to a classroom.  If they are a teacher, they are allocated to a classroom based on their agent ID, so that teachers are spread between classrooms.\n\n    def Initialise_Location(self,all_locations,assigned_teacher_classrooms, prob_follow_group):\n\n#        no_locations=len(all_locations)\n\n        poss_initial_locations=self.all_classrooms ##the possible initial locations are classrooms\n\n        initial_location=int(np.random.permutation(poss_initial_locations)[0]) ##select one of the classrooms at random\n        \n        r=np.random.random()\n\n        if r<prob_follow_group:\n            \n            own_group=self.movement_group\n            \n            initial_location=int(self.group_goals[own_group])\n        \n        ##place any teacher into a single classroom\n        \n        agent_type=self.agent_type\n        \n        if agent_type==2: ##if the agent is a teacher\n        \n            no_classrooms=len(assigned_teacher_classrooms) ##check the number of classrooms\n        \n            classroom_id=int(np.mod(self.agent_id,no_classrooms)) ##and use the agent ID to work out which class to put the teacher in\n            \n            initial_location=int(assigned_teacher_classrooms[classroom_id]) ##assign this as the initial location\n            \n            self.goal_location=initial_location ##and also set the goal to the current location for the teachers that don't move\n            \n        self.current_location=initial_location ##and set the current location\n\n        current_location_coords=all_locations[initial_location].coords ##set the coordinates...\n\n        new_agent_coords_shift=np.random.random(2)-0.5  ##...and shift them a little so that not everyone is in the same place\n\n        new_agent_coords=new_agent_coords_shift+current_location_coords\n\n        #print(\"current_agent coords = \",new_agent_coords)\n\n        self.current_position=new_agent_coords\n\n    ##################################\n    \n    ##this function just records the type (set globally when initialising the variables)\n    \n    ##Function: Initialise_Agent_Type\n    \n    ##Inputs: Vector of agent types\n    \n    ##Outputs: The individual agents type\n    \n    ##What it does\n    \n    ##A simple function to assign the agent type\n\n    def Initialise_Agent_Type(self,initial_agent_types):\n\n        self.agent_type=initial_agent_types[self.agent_id]\n\n    ##################################\n    \n    ##this function randomly assigns the agent a class\n    \n    ##Function: Initialise_Agent_Class\n    \n    ##Inputs: The number of classes, and the probability of each\n    \n    ##Outputs: The selected agent's class\n    \n    ##What it does\n    \n    ##Randomly assigns the agent a class based on the probability distribution of the classes\n\n    def Initialise_Agent_Class(self,no_classes,class_prob_dist):\n    \n        sel_class=np.random.choice(no_classes, 1, p=class_prob_dist)\n\n        self.agent_class=sel_class[0]\n        \n#        print(\"sel_class = \",self.agent_class)\n\n    ##################################\n    \n    ##this function sets which times and locations are stressful for this agent\n    \n    ##Function: Initialise_Agent_Location_Time_Stress\n    \n    ##Inputs: All locations, the total number of time steps\n    \n    ##Outputs: A baseline stress for each time and location for this specific agent\n    \n    ##What it does\n    \n    ##This assigns a random stress to each classroom for the agent, to match the fact that some classrooms are more or less nice.  The function also does the same for specified time steps, in particular those in the middle 10% and the last 20% of the day.\n    \n    def Initialise_Agent_Location_Time_Stress(self,all_locations,no_time_steps, mean_time_stress, mean_room_stress, inc_walking_perspective):\n\n        if self.agent_type!=2: ##if the agent is a student\n\n            no_locations=len(all_locations)\n\n            self.location_stress=np.zeros([no_locations]) ##initialise a vector of stress for each location\n\n            self.time_stress=np.zeros([no_time_steps]) ##and initialise a vector of stress for each time step\n\n            ind_time_stress=np.random.normal(loc=mean_time_stress)#*0.05 ##generate a constant random number for how stressful stressful times are for this agent\n            \n            if ind_time_stress<0:\n            \n                ind_time_stress=0\n                \n            if inc_walking_perspective==1:\n\n                for time in np.arange(no_time_steps): ##assign the correct stress for each time step\n\n    #                if time/no_time_steps>0.8: ##if the time is above 80% of the time, individuals find it stressful\n\n                        self.time_stress[time]=ind_time_stress\n                        \n     #               if time/no_time_steps>0.45 and time/no_time_steps<0.55: ##and if it's between 45% and 55%\n\n      #                  self.time_stress[time]=ind_time_stress\n                        \n                poss_classrooms=self.all_classrooms\n                \n                for sel_location in poss_classrooms: ##for each classroom, randomly assign a stress\n                    \n                    sel_room_stress=np.random.normal(loc=mean_room_stress, scale=0.1)\n                    \n                    if sel_room_stress<0:\n                    \n                        sel_room_stress=0\n                    \n                    self.location_stress[int(sel_location)]=sel_room_stress\n                \n\n    ##################################\n    \n    ##this function sets a new goal destination for the agent\n    \n    ##Function: Set_New_Goal_Class\n    \n    ##Inputs: The probability of moving if the agent is a teacher\n    \n    ##Outputs: The new classroom set as the goal\n    \n    ##What it does\n    \n    ##When a new goal is required, the agent is assigned a new classroom to aim to travel to (note: with some probability this will be their current location).\n\n    def Set_New_Goal_Class(self, prob_teacher_moving, canteen_prob, current_lunch_time, prob_follow_group):\n        \n        old_goal=self.goal_location ##register the old goal, as for the teachers the goal may not change\n        \n#        sel_goal=old_goal\n    \n        agent_type=self.agent_type ##agent type\n        \n        if current_lunch_time==0:\n        \n            poss_goal_locations=self.all_classrooms ##the goals are the classrooms\n            \n            sel_goal=int(np.random.permutation(poss_goal_locations)[0]) ##select one at random\n\n        if current_lunch_time==1:\n            \n            if agent_type!=2: ##if the agent is a student....\n                \n                r=np.random.random()\n            \n                if r<canteen_prob:\n                    \n                    sel_goal=self.all_canteens[0]\n                    \n                else:\n                    \n                    poss_goal_locations=self.available_locations\n                    \n                    sel_goal=int(np.random.permutation(poss_goal_locations)[0]) ##select one at random\n                    \n                    #print(\"sel_goal = \",sel_goal)\n            \n            if agent_type==2: ##if the agent is a teacher....\n\n                sel_goal=self.all_staffrooms[0]\n\n        if agent_type==2: ##if the agent is a teacher....\n        \n            r=np.random.random()\n            \n            if r>prob_teacher_moving: ##...and by chance they don't move\n            \n                sel_goal=old_goal ##set the new goal to the old goal\n                \n        if agent_type!=2: ##if the agent is not a teacher....\n                \n            r=np.random.random()\n\n            if r<prob_follow_group:\n                \n                own_group=self.movement_group\n                \n                sel_goal=int(self.group_goals[own_group])\n\n        self.goal_location=sel_goal\n        \n    ##################################\n        \n    def Set_New_Goal_Toilet(self):\n        \n        old_goal=self.goal_location ##register the old goal, as for the teachers the goal may not change\n        \n        poss_goal_locations=self.all_toilets ##the goals are the classrooms\n\n        sel_goal=int(np.random.permutation(poss_goal_locations)[0]) ##select one at random\n        \n        self.goal_location=sel_goal\n\n        \n    ##################################\n    \n    ##this function uses the library nx to find the shortest path to the new goal, which then gives the \"ideal path length\" if nothing goes wrong\n    \n    ##Function: Ideal_Goal_Length\n    \n    ##Inputs: All locations; the network of connected locations, G.\n    \n    ##Outputs: The shortest path to the agent's goal.\n    \n    ##What it does\n    \n    ##This function finds the shortest path the agent should take to their goal.  This therefore provides the time the agent assumes it should take, rather than how long it actually may take due to random events.\n\n    def Ideal_Goal_Length(self,all_locations,G):\n    \n        current_location=self.current_location\n\n        path_to_goal = nx.shortest_path(G, self.current_location, self.goal_location)\n\n        self.ideal_goal_length=len(path_to_goal)\n\n    ##################################\n    \n    ##this function moves the agent to the next location on the shortest path to their goal\n    \n    ##Function: Move_Agent\n    \n    ##Inputs: All locations; the agent's own current location; the network of connected locations, G.\n    \n    ##Outputs: An updated location (and coordinates) for the agent; an updated journey time\n    \n    ##What it does\n    \n    ##This function finds the next step in the shortest route between the agent's current location and their goal, and moves them to this point (and generates some random coordinates within the location for plotting).  It also updates how long the journey has been going on for.\n\n    def Move_Agent(self,all_locations,G):\n\n        current_location=self.current_location\n\n        path_to_goal = nx.shortest_path(G, self.current_location, self.goal_location) ##calculate the shortest path to the goal\n\n        if len(path_to_goal)>1: ##if they have some distance to go\n        \n            self.journey_time=self.journey_time+1 ##add one to the journey time\n\n            new_location=path_to_goal[1] ##set the new location to the next path\n\n            self.current_location=new_location\n\n            current_location_coords=all_locations[new_location].coords ##and set the new coordinates...\n\n            new_agent_coords_shift=np.random.random(2)-0.5 ##...with a little jiggle for plotting\n\n            new_agent_coords=current_location_coords+new_agent_coords_shift\n\n            self.current_position=new_agent_coords\n            \n        else:\n        \n            self.journey_time=0\n\n\n    ############################################\n\n    ##functions related to relationship quality\n\n    ##################################\n    \n    ##this function initialises the relationship quality between -1 and 1 between all agents\n    \n    ##Function: Initialise_RQ\n    \n    ##Inputs: All agents\n    \n    ##Outputs: A relationship quality between the agent and others.\n    \n    ##What it does\n    \n    ##This function assigns a random number between -1 and 1 as the initial relationship quality between the agents.\n\n    def Initialise_RQ(self, all_agents, emp_networks, initial_agent_types, no_teachers, use_emp_networks):\n\n        no_agents=len(all_agents)\n        \n        no_students=len(np.where(initial_agent_types!=2)[0])\n\n#        print(\"No students = \",no_students)\n        \n        sel_agent=self.agent_id\n        \n        if use_emp_networks==1:\n\n            all_sel_agent_student_rq=np.array(emp_networks.iloc[:,(sel_agent-no_teachers)])\n\n            #no_network_students=len(all_sel_agent_student_rq)\n\n            #print(\"No network students = \",no_network_students)\n\n            sel_agent_student_rq=all_sel_agent_student_rq[0:no_students]\n\n            sel_agent_rq=np.zeros(no_agents)\n\n            sel_agent_rq[initial_agent_types!=2]=sel_agent_student_rq\n\n #       print(\"sel_agent_rq\")\n\n  #      print(sel_agent_rq)\n\n            self.all_rq=sel_agent_rq#np.random.random(no_agents)*2-1\n            \n        else:\n            \n            self.all_rq=np.random.random(no_agents)*2-1\n\n        self.rq=np.sum(self.all_rq)\n\n    ##################################\n    \n    ##this function calculates the loneliness as a sum of all relationship quality\n    \n    ##Function: Update_Loneliness_Calc\n    \n    ##Inputs: The agent's relationship quality with all others\n    \n    ##Outputs: Loneliness (or really the inverse, which is the total relationship quality).\n    \n    ##What it does\n    \n    ##This function sums the agent's relationship quality across all other agent's to get a measure of loneliness.\n\n    def Update_Loneliness_Calc(self):\n\n        self.rq=np.sum(self.all_rq)\n        \n    ##################################\n    \n    ##this function updates the relationship quality of an agent based on the previous interactions\n    \n    ##Function: Update_All_RQ_Based_On_Interaction\n    \n    ##Inputs: Whether the agent has bullied or been bullied in the previous time step; the change in relationship quality based on whether an agent is bullied or been bullied\n    \n    ##Outputs: Updated relationship quality between the focal agent and all others\n    \n    ##What it does\n    \n    ##This function reduces the relationship quality between two agents if they bully another, or are bullied by another.\n\n    def Update_All_RQ_Based_On_Interaction(self,rq_decrease_through_bullying,rq_increase_through_support):\n\n        agent_type=self.agent_type ##agent type\n\n        if agent_type!=2: ##if the agent is not a teacher....\n\n            if self.bullied_by>-1: ##if the focal agent was bullied\n\n                self.all_rq[self.bullied_by]=self.all_rq[self.bullied_by]-rq_decrease_through_bullying ##decrease the RQ due to the bullying\n\n                self.bullied_by=-1\n\n            if self.bullying>-1: ##if the focal agent bullied\n\n                self.all_rq[self.bullying]=self.all_rq[self.bullying]-rq_decrease_through_bullying ##decrease the RQ due to the bullying\n\n                self.bullying=-1\n\n            if self.supported_by>-1: ##if the focal agent is socially supported\n\n                self.all_rq[self.supported_by]=self.all_rq[self.supported_by]+rq_increase_through_support ##increase the RQ due to the social support\n\n                self.bullied_by=-1\n\n    ############################################\n\n    ##functions related to stress and status\n\n    ##################################\n    \n    ##this function updates the status based on providing or receiving a negative social interaction\n    \n    ##Function: Update_Status\n    \n    ##Inputs: Agent type; the agent's current status; whether a negative interaction was received or provided in the last time step.\n    \n    ##Outputs: The updated agent status\n    \n    ##What it does\n    \n    ##This function increases an agent's status if they have provided a negative interaction, and reduces it if they've been the subject of one.\n\n    def Update_Status(self,status_increase,status_decrease):\n\n        agent_type=self.agent_type\n\n        if agent_type!=2: ##if the agent is a student\n\n            self.status=self.status+status_increase*self.neg_int_prov-status_increase*self.neg_int_rec ##update the status\n\n            if self.status<0: ##make sure the status isn't negative\n\n                self.status=0\n\n            self.neg_int_prov=0\n\n            self.neg_int_rec=0\n                \n    ##################################\n    \n    ##this function decays the stress\n    \n    ##Function: Decay_Stress\n     \n    ##Inputs: Stress decay rate\n    \n    ##Outputs: Updated agent stress\n    \n    ##What it does\n    \n    ##Decays the stress of students\n\n    def Decay_Stress(self, stress_decay, time):\n\n        agent_type=self.agent_type\n        \n        base_stress=0\n        \n        if agent_type!=2: ##if the agent is a student\n\n            current_location=self.current_location\n            \n            base_stress=self.location_stress[current_location]+self.time_stress[time]\n\n            if base_stress<0:\n            \n                base_stress=0\n\n        self.stress=self.stress-(self.stress-base_stress)*stress_decay ##update the stress\n                \n        if self.stress<0:\n        \n            self.stress=0\n                \n    ##################################\n    \n    ##this function adds stress based on the time step\n    \n    ##Function: Decide_If_Stressed_Due_To_Time\n    \n    ##Inputs: agent type; agent stress in each time\n    \n    ##Outputs: Updated agent stress\n    \n    ##What it does\n    \n    ##Adds the base time stress to the agent's stress.\n\n    def Decide_If_Stressed_Due_To_Time(self,all_locations,status_threshold,time):\n\n        agent_type=self.agent_type\n\n        if agent_type!=2: ##if the agent is a student\n\n            self.stress=self.stress+self.time_stress[time] ##add the correct stress from the time step\n                \n    \n    \n    ##################################\n    \n    ##this function adds stress based on the location\n    \n    ##Function: Decide_If_Stressed_Due_To_Location\n    \n    ##Inputs: agent type; agent stress in each location\n    \n    ##Outputs: Updated agent stress\n    \n    ##What it does\n    \n    ##Adds the base location stress to the agent's stress.\n\n    def Decide_If_Stressed_Due_To_Location(self,all_locations,status_threshold,time):\n\n        agent_type=self.agent_type\n\n        if agent_type!=2: ##if the agent is a student\n\n            current_location=self.current_location\n\n            self.stress=self.stress+self.location_stress[current_location] ##add the correct stress for the location\n\n            \n    ##################################\n    \n    ##this function decides if the agent is stressed due to a delay\n    \n    ##Function: Decide_If_Stressed_Due_To_Delay\n    \n    ##Inputs: agent type; agent journey time; agent ideal goal length\n    \n    ##Outputs: Updated agent stress\n    \n    ##What it does\n    \n    ##If the journey between classrooms has taken longer than initially calculated, the agent becomes more stressed.\n    \n    def Decide_If_Stressed_Due_To_Delay(self,journey_stress):\n\n        agent_type=self.agent_type\n\n        if agent_type!=2: ##if the agent is a student\n        \n            time_diff=self.journey_time-self.ideal_goal_length ##if the journey time is longer than the time it should have taken when the goal was set\n        \n            if time_diff>0:\n\n                self.stress=self.stress+journey_stress ##add the journey stress\n\n\n    ##################################\n    \n    ##this function makes an agent stressed if there are too many others in the same location\n    \n    ##Function: Decide_If_Stressed_Due_To_Crowdedness\n    \n    ##Inputs: agent type; agent location; other agents in the location; other agent types in the location; is the location a classroom?; number of students required in a location to make it stressful; stress due to being in a crowded location.\n    \n    ##Outputs: Updated agent stress\n    \n    ##What it does\n    \n    ##If the agent isn't in a classroom or in a location with a teacher, but the number of other students is larger than the threshold, then increase the agent's stress by the amount given by the parameter.\n\n    def Decide_If_Stressed_Due_To_Crowdedness(self,all_locations,crowded_threshold,crowded_stress):\n\n        agent_type=self.agent_type\n\n        if agent_type!=2: ##if the agent is a student\n\n            current_location=self.current_location\n\n            agents_here=all_locations[current_location].agents_in_location ##check how many agents there are in the current location\n            \n            no_agents_here=len(agents_here)-1\n            \n            is_loc_classroom=all_locations[current_location].is_classroom ##check if the location is a classroom (as crowdedness is only a factor outside)\n\n            agent_types_here=all_locations[current_location].no_agent_types_present ##check if there are any teachers in the location\n                \n            no_teachers=agent_types_here[2]\n\n            if no_agents_here>crowded_threshold and no_teachers==0 and is_loc_classroom==0: ##if the number of others is larger than the threshold, there are no teachers and the location isn't a classroom - add to the stress \n\n                self.stress=self.stress+crowded_stress\n\n\n    ##################################\n    \n    ##this function updates the stress of an individual due to any positive or negative interactions that have taken place\n    \n    ##Function: Update_Stress_Due_To_Interactions\n    \n    ##Inputs: agent type; agent location; agent types in the current location; is the student bullied in the current time step?; is the student supported in the current time step?; increase in stress due to a negative interaction; decrease in stress due to a positive interaction\n    \n    ##Outputs: Updated agent stress\n    \n    ##What it does\n    \n    ##If a student is negatively interacted with (and there are no teachers present), then the student's stress increases by the amount given by the parameter \"increase_in_stress_due_to_neg_int\", whilst if the student is positively interacted with the student's stress idecreases by the amount given by the parameter \"decrease_in_stress_due_to_pos_int\".\n\n    def Update_Stress_Due_To_Interactions(self,all_locations,all_agents,increase_in_stress_due_to_neg_int,decrease_in_stress_due_to_pos_int):\n\n        agent_type=self.agent_type\n\n        if agent_type!=2: ##if the agent is a student\n\n            current_location=self.current_location\n\n            agent_types_here=all_locations[current_location].no_agent_types_present ##check if there are any guardians present\n                \n            am_bullied=self.neg_int_rec ##check if the student has been bullied in the current time step\n\n            no_teachers=agent_types_here[2]\n\n            if no_teachers==0 and am_bullied==1: ##if the student is bullied, but there are no teachers increase stress\n\n                self.stress=self.stress+increase_in_stress_due_to_neg_int\n\n            am_supported=self.pos_int_rec ##check if the student was supported\n\n            if am_supported==1:\n\n                self.stress=self.stress-decrease_in_stress_due_to_pos_int ##if so, reduce the stress\n\n            if self.stress<0: ##make sure the stress is never negative\n\n                self.stress=0\n            \n    ##################################\n    \n    ##this function updates the stress due to a class interaction (based on e.g., uniform)\n    \n    ##Function: Update_Stress_Due_To_Class_Interactions\n    \n    ##Inputs: increase in stress through a class interaction; decrease in stress due to a positive interaction; did the individual receive or instigate a negative interaction based on class?; was the agent supported?\n    \n    ##Outputs: Updated agent stress\n    \n    ##What it does\n    \n    ##This function checks if there was a negative class interaction, and then update the stress accordingly.\n            \n    def Update_Stress_Due_To_Class_Interactions(self,stress_through_class_interaction,decrease_in_stress_due_to_pos_int):\n\n        am_bullied=self.neg_class_int_rec ##check if there was a negative class interaction\n\n        if am_bullied==1: ##if so, increase stress\n\n            self.stress=self.stress+stress_through_class_interaction\n\n        am_supported=self.pos_int_rec ##if the student is supported, reduce the stress\n\n        if am_supported==1:\n\n            self.stress=self.stress-decrease_in_stress_due_to_pos_int\n\n        class_int_prov=self.neg_class_int_prov ##if the individual is the instigator of the class based interaction, then increase their stress too\n\n        if class_int_prov==1:\n\n            self.stress=self.stress+stress_through_class_interaction\n\n        if self.stress<0: ##and then ensure that the stress isn't negative\n\n            self.stress=0\n            \n    ##################################\n    \n    ##this function decides if there is a negative interaction between a student and a teacher\n    \n    ##Function: Decide_Negative_Class_Interaction\n    \n    ##Inputs: all agent types; current agent location; all agents in the current location; agent classes \n    \n    ##Outputs: negative interaction provided; negative interaction received \n    \n    ##What it does\n    \n    ##This function decides if a teacher has a negative interaction based on class.  The focal teacher looks at all students in the same location, and selects one of the students with a lower class to negatively interact with.\n\n    def Decide_Negative_Class_Interaction(self,all_agents,all_locations):\n\n        agent_type=self.agent_type ##check the agent type\n\n        if agent_type==2: ##if the agent is a teacher\n\n            current_location=self.current_location ##check the current location\n\n            agents_here=all_locations[current_location].agents_in_location ##and check which other agents are here\n\n            teacher_class=self.agent_class ##check the class of the focal teacher\n\n            poss_agents_to_bully=[] ##initialise the vector of the potential agents to interact negatively with\n\n            for sel_agent in agents_here.astype(int): ##cycle through all the agents on the location and check if there are differences in the class between the teacher and others\n\n            #\t\t\t\tprint(\"sel_agent = \",sel_agent)\n\n                other_agent_class=all_agents[sel_agent].agent_class\n\n                class_diff=(teacher_class-other_agent_class) ##is the teacher class more strict than the student class?\n                \n#                print(\"Class diff = \",class_diff)\n                \n                if class_diff>0: ##and if so add this to the list of possible agents to interact negatively with\n\n                    poss_agents_to_bully.append(sel_agent)\n                \n                \n            ##select an agent to bully\n\n            no_agents_to_bully=len(poss_agents_to_bully)\n\n            if no_agents_to_bully>0: ##if there are any agents to interact negatively with\n\n                sel_agent_to_bully=np.random.permutation(poss_agents_to_bully)[0] ##select one at random\n\n                self.neg_class_int_prov=1 ##and set the bully/bullied variables to 1\n\n                self.bullying=sel_agent_to_bully\n\n                all_agents[sel_agent_to_bully].neg_class_int_rec=1\n\n                all_agents[sel_agent_to_bully].bullied_by_class=self.agent_id\n\n    ##################################\n    \n    ##this function decides if there is a negative interaction between students based on 1) differences in status and 2) how stressed the focal student is\n    \n    ##Function: Decide_Negative_Interaction\n    \n    ##Inputs: agent type; status threshold; stress to bully parameter; status of all agent's in the location; relationship quality between all agent's in the location\n    \n    ##Outputs: negative interaction provided; negative interaction received\n    \n    ##What it does\n    \n    ##This function decides if an agent interacts negatively with another based on the scientific perspective, and if so which other agent.  The agent first compares the status difference (moderated by relationship quality) with all others agents, and if this calculation is larger than the set threshold parameter then the other agent is added to the list of possible agents to interact negatively with.  After this, the agent selects one of the possible agents in the location to interact negatively with.  For the stress level, the agent stress is multiplied by the stress bully scale, and placed into a tanh function to change this into a probability.  The agent then selects another agent in the location to interact with negatively with the probability calculated.\n\n    def Decide_Negative_Interaction(self,all_agents,all_locations,status_threshold,stress_bully_scale):\n\n        agent_type=self.agent_type ##check the agent type\n\n        current_location=self.current_location ##check the current location\n\n        if agent_type!=2: ##if the agent is a student\n\n            own_status=self.status ##check the status of the focal individual\n\n            current_rqs=self.all_rq ##and the relationship quality with all others\n\n            #\t\t\tprint(\"current_rqs\")\n\n            #\t\t\tprint(current_rqs)\n\n            agent_types_here=all_locations[current_location].no_agent_types_present ##and check which other agent types are here\n\n            agent_status_here=all_locations[current_location].agent_status ##and what their status is\n\n            agents_here=all_locations[current_location].agents_in_location ##and check which other agents are here\n\n            poss_agents_to_bully=[] ##initialise a vector of those to bully\n\n            for sel_agent in agents_here.astype(int): ##and cycle through all the agents present to check which satisfy the conditions for a negative interaction (given as a combination of the status difference and the relationship quality between the two\n\n            #\t\t\t\tprint(\"sel_agent = \",sel_agent)\n\n                other_agent_status=all_agents[sel_agent].status ##the other agents status\n\n                rq_with_other_agent=current_rqs[sel_agent] ##and relationship quality\n\n            #\t\t\t\tprint(\"rq = \",rq_with_other_agent)\n\n                status_diff=(other_agent_status-own_status)*rq_with_other_agent ##choose to interact negatively if have a negative rq and their status is small enough, and then compare this multiplication to the status threshold\n\n                if status_diff>status_threshold: ##if this quantity is above a threshold\n\n                    poss_agents_to_bully.append(sel_agent) ##add to the possible agents to bully\n                \n                \n            ##select an agent to bully\n\n            no_agents_to_bully=len(poss_agents_to_bully) \n\n            if no_agents_to_bully>0: ##if there are agents to bully\n\n                sel_agent_to_bully=np.random.permutation(poss_agents_to_bully)[0] ##select one at random\n\n                self.neg_int_prov=1 ##and set the bully/bullied variables to 1\n\n                self.bullying=sel_agent_to_bully\n\n                all_agents[sel_agent_to_bully].neg_int_rec=1\n\n                all_agents[sel_agent_to_bully].bullied_by=self.agent_id\n                \n        ###################\n        \n        ##also interact negatively if the agent is stressed\n        \n        agent_stress=self.stress ##the focal agent stress\n\n        probability_of_negative_interaction=np.tanh(stress_bully_scale*agent_stress) ##calculate the probability of a negative interaction based on the agent's stress\n\n#        print(\"agent_stress = \",agent_stress,\", prob of int = \",probability_of_negative_interaction)\n\n        r=np.random.random() ##generate a random number...\n        \n        if r<probability_of_negative_interaction: ##...and if this is smaller that the probability of interaction, select another agent to interact negatively with\n        \n            ##select another agent to interact negatively with\n            \n            agents_here=all_locations[current_location].agents_in_location ##check which agents are in the location\n            \n            this_agent_id=self.agent_id\n            \n         #   print(\"Agents here\")\n            \n          #  print(agents_here)\n            \n            other_agents_here=agents_here[np.where(agents_here!=this_agent_id)[0]] ##remove the focal agent from the possibles list\n            \n           # print(\"Other agents here\")\n            \n            #print(other_agents_here)\n            \n            if len(other_agents_here)>1: ##if there are other agents, pick one at random to negatively interact with\n            \n                sel_agent_to_bully=int(np.random.permutation(other_agents_here)[0])\n\n             #   print(\"sel_agent_to_bully = \",sel_agent_to_bully)\n\n                self.neg_int_prov=1 ##and set the bully/bullied variables to 1\n\n                self.bullying=sel_agent_to_bully\n\n                all_agents[sel_agent_to_bully].neg_int_rec=1\n\n                all_agents[sel_agent_to_bully].bullied_by=self.agent_id\n            \n            \n            \n    ##################################\n    \n    ##this function decides if there should be a positive interaction between students\n    \n    ##Function: Decide_Positive_Interaction\n    \n    ##Inputs: agent type; current agent location; relationship quality between all agents in the location; whether each agent in the location has received a negative interaction\n    \n    ##Outputs: positive support provided; positive support received\n    \n    ##What it does\n    \n    ##This function decides if social support is provided between individuals.  The agent identifies those friends (those other agents in the location with a positive relationship quality) that are being bullied, and selects one at random to socially support.\n            \n    def Decide_Positive_Interaction(self,all_agents,all_locations):\n\n        ##find the friends in the location\n\n        agent_type=self.agent_type ##check the agent type\n\n        if agent_type!=2: ##if the agent is a student\n\n            current_location=self.current_location ##check the current location,\n\n            current_rqs=self.all_rq ##check the focal agents relationship quality with all other agents\n\n            #\t\t\tprint(\"current_rqs\")\n\n            #\t\t\tprint(current_rqs)\n\n            agents_here=(all_locations[current_location].agents_in_location).astype(int) ##and check which other agents are here\n\n            #\t\t\tprint(\"agents_here\")\n\n            #\t\t\tprint(agents_here)\n\n            location_rqs=current_rqs[agents_here] ##and then select the relationship quality of all others present\n\n            #\t\t\tprint(\"location_rqs\")\n\n            #\t\t\tprint(location_rqs)\n\n            friends_loc=np.where(location_rqs>0)[0] ##find which part of the previous vector includes those that have a positive relationship quality...\n\n            location_friends=agents_here[friends_loc] ##...and using this identify which individuals in the same location are friends\n\n            #\t\t\tprint(\"location_friends\")\n\n            #\t\t\tprint(location_friends)\n\n            no_location_friends=len(location_friends)\n\n            bullied_friends=np.zeros(no_location_friends) ##initialise a vector to check which friends are being bullied, and therefore require support\n\n            for sel_friend_id in np.arange(no_location_friends): ##for each friend in the current location...\n\n                sel_friend=location_friends[sel_friend_id]\n\n                bullied_friends[sel_friend_id]=all_agents[sel_friend].neg_int_rec ##check if that friend is bullied\n\n                #\t\t\tprint(\"bullied_friends\")\n\n                #\t\t\tprint(bullied_friends)\n\n            no_bullied_friends=np.sum(bullied_friends) ##check how many bullied friends there are in the location \n\n            sel_supported_friend=-1 ##initialise which friend to support\n\n            if no_location_friends>0: ##if there are friends present...\n\n                if no_bullied_friends>0: ##...and if at least one of them is being bullied\n\n                    poss_supported_friends_ids=np.where(bullied_friends==1)[0]\n                    \n                    poss_supported_friends=location_friends[poss_supported_friends_ids]\n                    \n                    sel_supported_friend=np.random.permutation(poss_supported_friends)[0] ##select one of these friends at random to support\n                    \n                else:\n\n                    sel_supported_friend=np.random.permutation(location_friends)[0] ##otherwise, just choose a non-bullied friend to have a positive interaction with\n\n                self.pos_int_prov=1 ##set the agent indicators to show they have provided and received a positive interaction\n\n                self.supporting=sel_supported_friend\n\n                all_agents[sel_supported_friend].pos_int_rec=1\n\n                all_agents[sel_supported_friend].supported_by=self.agent_id\n\n                #\t\t\tprint(\"sel_supported_friend\")\n\n                #\t\t\tprint(sel_supported_friend)\n\n    ##################################\n    \n    def Calc_Network_Degree(self):\n    \n        ind_rq=self.all_rq\n        \n        pos_deg=0\n        \n        neg_deg=0\n        \n        for partner_rq in ind_rq:\n            \n            if partner_rq>5:\n                \n                pos_deg=pos_deg+1\n                \n            if partner_rq<-80:\n                \n                neg_deg=neg_deg+1\n\n        self.pos_deg=pos_deg\n        \n        self.neg_deg=neg_deg\n        \n        \n\n\n    ##################################\n    \n    ##this function records all of the necessary information in this time step for this agent\n \n    def Record_Agent_Info(self,time):\n\n        self.agent_info[time,[0,1]]=self.current_position\n\n        self.agent_info[time,2]=self.agent_type\n        \n        self.agent_info[time,3]=self.stress\n        \n        self.agent_info[time,4]=self.rq\n        \n        self.agent_info[time,5]=self.status\n        \n        self.agent_info[time,6]=self.pos_deg\n        \n        self.agent_info[time,7]=self.neg_deg\n\n        self.agent_info[time,8]=self.current_location\n\n\n\n\n\n\n\n\n\n\n", "type": "text"}, {"name": "general_functions.py", "content": "#location: cd Desktop/socits/model/full_model/status\n\n#to run: python3 static_network.py\n\n########################################################\n\n##Part A: load in the libraries and functions for running the code\n\n##libraries\n\nimport random\nfrom random import randint\nimport numpy as np\nimport csv\nimport time\nimport os\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\nimport networkx as nx\n\nfrom functools import partial\n\nimport scipy as sp\n\n##and the function files\n\nfrom agent_class import Agent\nfrom location_class import Location\n\n########################################################\n\n##functions\n\n#############\n\n##function to generate the adjacency matrix for each location\n\n##Function: Generate_Location_Grid\n\n##Inputs: school map; all locations\n\n##Outputs: the location grid matrix\n\n##What it does\n\n##Using the school map a matrix of allowed, movable locations for each location is developed by comparing the allowed neighbours for each location.\n\ndef Generate_Location_Grid(school_map,all_locations):\n\n    ##calculate the number of locations based on the school map\n\n    grid_width=len(school_map[:,0])\n    \n    grid_length=len(school_map[0,:])\n\n#    grid_size=grid_width*grid_length\n\n#    print(\"Grid width = \",grid_width)\n    \n #   print(\"Grid length = \",grid_length)\n\n    no_locations=grid_width*grid_length\n\n    location_grid_matrix=np.zeros([no_locations,grid_width,grid_length]) ##initialise the grid for all of the allowed locations to move from the specific location\n\n    for sel_location in np.arange(no_locations): ##moving through each location\n\n        location_coords=all_locations[sel_location].coords ##find the coordinates\n\n        #\t\tlocation_grid_matrix[sel_location,location_coords[0],location_coords[1]]=1\n\n        ##based on the school map, set as a one places which can be moved to from the selected location\n        \n        ##Note: the different if loops below just include the different boundary possibilities i.e., the map is NOT a torus \n\n        if location_coords[0]>0:\n\n            if school_map[location_coords[0]-1,location_coords[1]]==1:\n\n                location_grid_matrix[sel_location,location_coords[0]-1,location_coords[1]]=1\n\n        if location_coords[0]<(grid_width-1):\n\n            if school_map[location_coords[0]+1,location_coords[1]]==1:\n\n                location_grid_matrix[sel_location,location_coords[0]+1,location_coords[1]]=1\n\n        if location_coords[1]>0:\n\n            if school_map[location_coords[0],location_coords[1]-1]==1:\n\n                location_grid_matrix[sel_location,location_coords[0],location_coords[1]-1]=1\n\n        if location_coords[1]<(grid_length-1):\n\n            if school_map[location_coords[0],location_coords[1]+1]==1:\n\n                location_grid_matrix[sel_location,location_coords[0],location_coords[1]+1]=1\n\n        if location_coords[0]>0 and location_coords[1]>0:\n\n            if school_map[location_coords[0]-1,location_coords[1]-1]==1:\n\n                location_grid_matrix[sel_location,location_coords[0]-1,location_coords[1]-1]=1\n\n        if location_coords[0]<(grid_width-1) and location_coords[1]<(grid_length-1):\n\n            if school_map[location_coords[0]+1,location_coords[1]+1]==1:\n\n                location_grid_matrix[sel_location,location_coords[0]+1,location_coords[1]+1]=1\n\n        if location_coords[1]>0 and location_coords[0]<(grid_width-1):\n\n            if school_map[location_coords[0]+1,location_coords[1]-1]==1:\n\n                location_grid_matrix[sel_location,location_coords[0]+1,location_coords[1]-1]=1\n\n        if location_coords[1]<(grid_length-1) and location_coords[0]>0:\n\n            if school_map[location_coords[0]-1,location_coords[1]+1]==1:\n\n                location_grid_matrix[sel_location,location_coords[0]-1,location_coords[1]+1]=1\n\n    return(location_grid_matrix)\n\n\n########################################################\n\n##function to generate a school map with a corridor of a certain size\n\n##Function: Generate_Corridor\n\n##Inputs: school map; grid length; grid width; corridor width\n\n##Outputs: the updated school map\n\n##What it does\n\n##Adds a corridor to the school map of a certain size\n\ndef Generate_Corridor(school_map,grid_width,grid_length,corridor_width):\n\n\tleft_wall=np.round(grid_width/2)-np.round(corridor_width/2) ##where should the left wall of the corridor be?\n\n\tprint(\"left wall = \",left_wall)\n\n\tright_wall=np.round(grid_width/2)+np.floor(corridor_width/2) ##and the right?\n\n\tprint(\"right wall = \",right_wall)\n\n\tfor i in np.arange(grid_width): ##across the width\n\n\t\tif i<left_wall or i>right_wall: ##if the grid point falls outside the corridor...\n\t\t\n\t#\tif i<4 or i>5:\n\n\t\t\tfor j in np.arange(grid_length):\n\t\t\t\n\t\t\t\tif j>1 and j<(grid_length-2): ##...and is between the classrooms...\n\t\t\t\n\t\t\t\t\tschool_map[i,j]=0 ##...then this is not an allowed location\n\n\treturn(school_map)\n    \n    \n    \n########################################################\n\n##function to generate a map of a floor with a corridor of a certain size\n\n##Function: Generate_Floor_Corridor\n\n##Inputs: school map; grid length; floor width; corridor width\n\n##Outputs: the updated school map\n\n##What it does\n\n##Adds a corridor to the school map of a certain size on the ground or upper floor of the two floor school\n\ndef Generate_Floor_Corridor(school_map,grid_length,floor_width,corridor_width):\n\n\tleft_wall=np.round(floor_width/2)-np.round(corridor_width/2) ##where should the left wall of the corridor be?\n\n#\tprint(\"left wall = \",left_wall)\n\n\tright_wall=np.round(floor_width/2)+np.floor(corridor_width/2) ##and the right?\n\n#\tprint(\"right wall = \",right_wall)\n\n\tfor i in np.arange(floor_width): ##across the floor width\n\n\t\tif i<left_wall or i>right_wall: ##if the grid point falls outside the corridor...\n\t\t\n\t#\tif i<4 or i>5:\n\n\t\t\tfor j in np.arange(grid_length):\n\t\t\t\n\t\t\t\tif j>1 and j<(grid_length-2): ##...and is between the classrooms...\n\t\t\t\n\t\t\t\t\tschool_map[i,j]=0 ##...then this is not an allowed location\n\n\treturn(school_map)\n\n\n#################################################################\n\n##function to generate a map of a school with two identical floors\n\n##Function: Generate_Two_Floor_School\n\n##Inputs: floor width; stair case width; corridor width\n\n##Outputs: school map\n\n##What it does\n\n##Runs the function \"Generate_Floor_Corridor\" twice, and sticks the results together to create a map of a two floor school with a corridor on each floor, and adds a staircase between them.\n\ndef Generate_Two_Floor_School(floor_width,stair_case_width,corridor_width):\n\n    grid_length=2*floor_width+stair_case_width ##set the length of the grid to be the addition of both floors and the staircase\n\n    school_map_left=np.ones([floor_width,floor_width]) ##initialise a full school map for the left hand school\n\n    school_map_left=Generate_Floor_Corridor(school_map_left,floor_width,floor_width,corridor_width) ##and generate a map with a corridor\n\n #   print(\"school_map_left\")\n\n  #  print(school_map_left)\n\n    school_map_right=np.ones([floor_width,floor_width]) ##initialise a full school map for the right hand school\n\n    school_map_right=Generate_Floor_Corridor(school_map_right,floor_width,floor_width,corridor_width) ##and generate a map with a corridor\n\n    staircase=np.zeros([stair_case_width,floor_width]) ##initialise a staircase map\n\n    for i in np.arange(stair_case_width): ##fill in the staircase\n\n        staircase[i,1]=1\n        staircase[i,floor_width-2]=1\n        \n   # print(\"staircase\")\n\n    #print(staircase)\n\n    school_map=np.vstack([school_map_left,staircase,school_map_right]) ##and add all these parts together to generate the school map\n\n    return(school_map)\n\n#################################################################\n\n##function to generate a map of a school with two identical floors, and a closed top stairwell\n\n##Function: Generate_Two_Floor_School_Shut_Top_Floor\n\n##Inputs: floor width; stair case width; corridor width\n\n##Outputs: school map\n\n##What it does\n\n##Runs the function \"Generate_Floor_Corridor\" twice, and sticks the results together to create a map of a two floor school with a corridor on each floor, and adds a staircase between them.  But in this case only the lower staircase is added so the top staircase is shut.\n\ndef Generate_Two_Floor_School_Shut_Top_Floor(floor_width,stair_case_width,corridor_width):\n\n    grid_length=2*floor_width+stair_case_width ##set the length of the grid to be the addition of both floors and the staircase\n\n    school_map_left=np.ones([floor_width,floor_width]) ##initialise a full school map for the left hand school\n\n    school_map_left=Generate_Floor_Corridor(school_map_left,floor_width,floor_width,corridor_width) ##and generate a map with a corridor\n\n #   print(\"school_map_left\")\n\n  #  print(school_map_left)\n\n    school_map_right=np.ones([floor_width,floor_width]) ##initialise a full school map for the right hand school\n\n    school_map_right=Generate_Floor_Corridor(school_map_right,floor_width,floor_width,corridor_width) ##and generate a map with a corridor\n\n    staircase=np.zeros([stair_case_width,floor_width]) ##initialise a staircase map\n\n    for i in np.arange(stair_case_width): ##fill in the staircase\n\n        staircase[i,1]=1 ##only include the bottom staircase\n #       staircase[i,grid_length-2]=1 \n        \n   # print(\"staircase\")\n\n    #print(staircase)\n\n    school_map=np.vstack([school_map_left,staircase,school_map_right]) ##and add all these parts together to generate the school map\n\n    return(school_map)\n\n\n\n#################################################################\n\n##function to generate a map of a school with two identical floors, and a closed bottom stairwell\n\n##Function: Generate_Two_Floor_School_Shut_Bottom_Floor\n\n##Inputs: floor width; stair case width; corridor width\n\n##Outputs: school map\n\n##What it does\n\n##Runs the function \"Generate_Floor_Corridor\" twice, and sticks the results together to create a map of a two floor school with a corridor on each floor, and adds a staircase between them.  But in this case only the upper staircase is added so the lower staircase is shut.\n\ndef Generate_Two_Floor_School_Shut_Bottom_Floor(floor_width,stair_case_width,corridor_width):\n\n    grid_length=2*floor_width+stair_case_width ##set the length of the grid to be the addition of both floors and the staircase\n\n    school_map_left=np.ones([floor_width,floor_width]) ##initialise a full school map for the left hand school\n\n    school_map_left=Generate_Floor_Corridor(school_map_left,floor_width,floor_width,corridor_width) ##and generate a map with a corridor\n\n #   print(\"school_map_left\")\n\n  #  print(school_map_left)\n\n    school_map_right=np.ones([floor_width,floor_width]) ##initialise a full school map for the right hand school\n\n    school_map_right=Generate_Floor_Corridor(school_map_right,floor_width,floor_width,corridor_width) ##and generate a map with a corridor\n\n    staircase=np.zeros([stair_case_width,floor_width]) ##initialise a staircase map\n\n    for i in np.arange(stair_case_width): ##fill in the staircase\n\n#        staircase[i,1]=1\n        staircase[i,floor_width-2]=1 ##only include the top staircase\n        \n   # print(\"staircase\")\n\n    #print(staircase)\n\n    school_map=np.vstack([school_map_left,staircase,school_map_right]) ##and add all these parts together to generate the school map\n\n    return(school_map)\n\n#################################################################\n\n##function to generate a graph linking all allowed locations based on whether a staircase is shut or not\n\n##Function: Update_Location_Graph\n\n##Inputs: all locations; corridors open; floor width; stair case width; corridor width\n\n##Outputs: G (the location graph)\n\n##What it does\n\n##Generates a location graph of a two floor school, depending on whether the top or bottom staircase is closed.\n\ndef Update_Location_Graph(all_locations,corridors_open,floor_width,stair_case_width,corridor_width):\n\n    ##generate the school map\n    \n    grid_size=2*floor_width+stair_case_width ##calculate the width of the grid\n    \n#    print(\"grid_size_1 = \",grid_size)\n    \n    no_locations=len(all_locations)\n    \n    ##generate the school map based on which staircase is open or closed\n\n    if corridors_open==0:\n\n        school_map=Generate_Two_Floor_School(floor_width,stair_case_width,corridor_width)\n\n#        print(\"school map\")\n        \n #       print(school_map)\n\n    if corridors_open==1:\n\n        school_map=Generate_Two_Floor_School_Shut_Top_Floor(floor_width,stair_case_width,corridor_width)\n        \n    if corridors_open==2:\n\n        school_map=Generate_Two_Floor_School_Shut_Bottom_Floor(floor_width,stair_case_width,corridor_width)\n\n#    print(\"school_map\")\n\n #   print(school_map)\n\n    ##generate the location adjacency matrix\n\n    location_grid_matrix=Generate_Location_Grid(school_map,all_locations)\n        \n    #print(\"location_grid_matrix\")\n\n    #print(location_grid_matrix)\n\n    ##generate the points to which each individual is allowed to move, along with the classrooms\n\n    for sel_location in np.arange(no_locations):\n\n        all_locations[sel_location].Is_Possible_Location(school_map)\n        \n        all_locations[sel_location].Is_Classroom(floor_width)\n        \n    poss_classrooms=[]\n    \n    for sel_location in np.arange(no_locations): ##and then initialise them\n    \n        if all_locations[sel_location].is_classroom==1:\n    \n            poss_classrooms=np.hstack([poss_classrooms,sel_location])\n    \n    #################\n    \n    ##allocate some rooms to take certain roles e.g., toilets, staff-room\n    \n    ##select two classrooms to be toilets\n    \n    non_classrooms=np.random.permutation(poss_classrooms)[0:4]\n    \n    ##and remove them from the list of possible classrooms\n    \n    non_class_index=np.isin(poss_classrooms, non_classrooms, invert=True)#[0]\n    \n#    print(\"non_class_index\")\n    \n #   print(non_class_index)\n    \n    poss_classrooms=poss_classrooms[non_class_index]\n\n#    print(\"selected_toilets = \",selected_toilets)\n    \n    assigned_teacher_classrooms=np.random.permutation(poss_classrooms)\n    \n    print(\"poss_classrooms\")\n    \n    print(poss_classrooms)\n    \n  #  print(\"Teacher classrooms\")\n    \n   # print(assigned_teacher_classrooms)\n        \n    for sel_location in np.arange(no_locations): ##and then initialise them\n        \n        all_locations[sel_location].Allocate_Room_Type(poss_classrooms, non_classrooms)\n        \n        all_locations[sel_location].Calc_Locations_To_Move_To(location_grid_matrix)\n\n        all_locations[sel_location].Allowed_Initial_Condition_Class(floor_width)\n        \n        \n\n    ##using this generate the graph\n\n    G = nx.Graph() ##initialise the graph\n\n    G.add_nodes_from([0, grid_size*grid_size-1]) ##add the number of nodes needed\n\n    for sel_location in np.arange(no_locations): ##for each location, look at where agents can move from this location, and then add edges to the graph for places to move to\n\n        locations_allowed_to_move_to=all_locations[sel_location].locations_to_move_to\n\n        for j in locations_allowed_to_move_to:\n\n            G.add_edge(sel_location, j)\n            \n           \n    return(G)\n\n\n##############################################################################################\n\n##Oblong map functions\n\n\n#############\n\n##function to generate the adjacency matrix for each location\n\n##Function: Generate_Oblong_Location_Grid\n\n##Inputs: floor width; floor length; all locations\n\n##Outputs: the location grid matrix\n\n##What it does\n\n##Based on the oblong map (where every location is allowed) a matrix of allowed, movable locations for each location is developed by comparing the allowed neighbours for each location.\n\ndef Generate_Oblong_Location_Grid(floor_width,floor_length,all_locations):\n\n    grid_size=floor_width*floor_length ##calculate the grid size\n\n    school_map=np.ones([floor_length,floor_width]) ##initialise a full school map\n\n#    print(\"Grid size = \",grid_size)\n\n    no_locations=grid_size ##set the number of locations\n\n #   print(\"School map\")\n        \n  #  print(school_map)\n        \n    location_grid_matrix=np.zeros([no_locations,floor_length,floor_width]) ##initialise the location grid matrix\n\n#    print(\"location_grid_matrix\")\n    \n #   print(location_grid_matrix)\n\n    for sel_location in np.arange(no_locations): ##for each location, record where the agent can move to from that location\n\n        location_coords=all_locations[sel_location].coords\n        \n #       print(\"Sel location = \",sel_location)\n        \n  #      print(\"Sel location coords = \",location_coords)\n\n        #\t\tlocation_grid_matrix[sel_location,location_coords[0],location_coords[1]]=1\n\n        ##based on the school map, set as a one places which can be moved to from the selected location\n        \n        ##Note: the different if loops below just include the different boundary possibilities i.e., the map is NOT a torus \n\n        if location_coords[0]>0:\n\n            if school_map[location_coords[0]-1,location_coords[1]]==1:\n\n                location_grid_matrix[sel_location,location_coords[0]-1,location_coords[1]]=1\n\n        if location_coords[0]<(floor_length-1):\n\n            if school_map[location_coords[0]+1,location_coords[1]]==1:\n\n                location_grid_matrix[sel_location,location_coords[0]+1,location_coords[1]]=1\n\n        if location_coords[1]>0:\n\n            if school_map[location_coords[0],location_coords[1]-1]==1:\n\n                location_grid_matrix[sel_location,location_coords[0],location_coords[1]-1]=1\n\n        if location_coords[1]<(floor_width-1):\n\n            if school_map[location_coords[0],location_coords[1]+1]==1:\n\n                location_grid_matrix[sel_location,location_coords[0],location_coords[1]+1]=1\n\n        if location_coords[0]>0 and location_coords[1]>0:\n\n            if school_map[location_coords[0]-1,location_coords[1]-1]==1:\n\n                location_grid_matrix[sel_location,location_coords[0]-1,location_coords[1]-1]=1\n\n        if location_coords[0]<(floor_length-1) and location_coords[1]<(floor_width-1):\n\n            if school_map[location_coords[0]+1,location_coords[1]+1]==1:\n\n                location_grid_matrix[sel_location,location_coords[0]+1,location_coords[1]+1]=1\n\n        if location_coords[1]>0 and location_coords[0]<(floor_length-1):\n\n            if school_map[location_coords[0]+1,location_coords[1]-1]==1:\n\n                location_grid_matrix[sel_location,location_coords[0]+1,location_coords[1]-1]=1\n\n        if location_coords[1]<(floor_width-1) and location_coords[0]>0:\n\n            if school_map[location_coords[0]-1,location_coords[1]+1]==1:\n\n                location_grid_matrix[sel_location,location_coords[0]-1,location_coords[1]+1]=1\n\n    return(location_grid_matrix)\n    \n#########################################################\n\n##function to generate the graph for an oblong map\n\n##Function: Generate_Oblong_Graph\n\n##Inputs: floor width; floor length; location grid matrix; all_locations\n\n##Outputs: G (the location graph)\n\n##What it does\n\n##Based on the location grid matrix, this function generates the graph on which to base the movements in an oblong map.\n\ndef Generate_Oblong_Graph(floor_width,floor_length,location_grid_matrix,all_locations):\n\n    school_map=np.ones([floor_length,floor_width]) ##initialise the school map\n\n    grid_size=floor_width*floor_length\n\n    no_locations=grid_size\n\n    ##generate the points to which each individual is allowed to move, along with the classrooms\n\n    for sel_location in np.arange(no_locations):\n\n        all_locations[sel_location].Is_Possible_Location(school_map)\n        \n        all_locations[sel_location].Is_Classroom_Oblong()\n        \n    poss_classrooms=[]\n    \n    for sel_location in np.arange(no_locations): ##and then initialise them\n    \n        if all_locations[sel_location].is_classroom==1:\n    \n            poss_classrooms=np.hstack([poss_classrooms,sel_location])\n    \n    #################\n    \n    ##allocate some rooms to take certain roles e.g., toilets, staff-room\n    \n    ##select two classrooms to be toilets\n    \n    non_classrooms=np.random.permutation(poss_classrooms)[0:4]\n    \n    ##and remove them from the list of possible classrooms\n    \n    non_class_index=np.isin(poss_classrooms, non_classrooms, invert=True)#[0]\n    \n#    print(\"non_class_index\")\n    \n #   print(non_class_index)\n    \n    poss_classrooms=poss_classrooms[non_class_index]\n\n#    print(\"selected_toilets = \",selected_toilets)\n    \n    assigned_teacher_classrooms=np.random.permutation(poss_classrooms)\n    \n    print(\"poss_classrooms\")\n    \n    print(poss_classrooms)\n    \n  #  print(\"Teacher classrooms\")\n    \n   # print(assigned_teacher_classrooms)\n        \n    for sel_location in np.arange(no_locations): ##and then initialise them\n        \n        all_locations[sel_location].Allocate_Room_Type(poss_classrooms, non_classrooms)\n\n        all_locations[sel_location].Calc_Locations_To_Move_To(location_grid_matrix)\n\n        all_locations[sel_location].Allowed_Initial_Condition_Class_Oblong()\n\n    ##using this generate a the graph\n\n    G = nx.Graph() ##initialise the graph\n\n    G.add_nodes_from([0, grid_size-1]) ##add the correct number of nodes\n\n    for sel_location in np.arange(no_locations): ##for each location, look at where agents can move from this location, and then add edges to the graph for places to move to\n\n        locations_allowed_to_move_to=all_locations[sel_location].locations_to_move_to\n\n        for j in locations_allowed_to_move_to:\n\n            G.add_edge(sel_location, j)\n            \n           \n    return(G)\n\n\n\n\n\n\n\n\n\n\n\n\n\n#######################################################################################################\n\ndef Assign_Groups(all_agents, no_groups):\n\n    no_agents=len(all_agents)\n \n    if no_groups>no_agents:\n        \n        no_groups=no_agents\n\n#    print(\"no_agents=\",no_agents)\n\n    ##code to assign movement groups\n\n    assigned_groups=np.ones(no_agents)*-1\n\n    #print(\"assigned_groups\")\n\n    #print(assigned_groups)\n\n    max_per_group=int(no_agents/no_groups)#+1\n\n    remaining_group_slots=np.ones(no_groups)*max_per_group\n\n    #print(\"remaining_group_slots\")\n\n    #print(remaining_group_slots)\n\n    ########\n\n    ##first group members\n\n    all_poss_group_members=np.random.permutation(no_agents)\n\n    initial_group_members=all_poss_group_members[0:no_groups]\n\n    assigned_groups[initial_group_members]=np.arange(no_groups)\n\n    #print(\"assigned_groups\")\n\n    #print(assigned_groups)\n\n    remaining_group_slots=remaining_group_slots-1\n\n    later_group_members=all_poss_group_members[no_groups:no_agents]\n\n    #next_ind=later_group_members[0]#np.random.permutation(np.where(assigned_groups==-1)[0])[0]\n\n    for next_ind in later_group_members:\n\n     #   print(\"next_ind = \",next_ind)\n\n        next_ind_rq=all_agents[next_ind].all_rq\n\n     #   print(\"next_ind_rq\")\n\n    #    print(next_ind_rq)\n\n        not_allowed_next_groups=np.where(remaining_group_slots<1)[0]\n\n     #   print(\"not_allowed_next_groups\")\n\n      #  print(not_allowed_next_groups)\n\n        group_rq=np.zeros(no_groups)\n\n        for sel_group in np.arange(no_groups):\n\n            sel_group_members=np.where(assigned_groups==sel_group)[0]\n            \n    #        print(\"sel_group_members\")\n            \n     #       print(sel_group_members)\n            \n            sel_group_rq=next_ind_rq[sel_group_members]\n\n      #      print(\"sel_group_rq\")\n            \n       #     print(sel_group_rq)\n            \n            group_rq[sel_group]=np.mean(sel_group_rq)\n            \n        group_rq[not_allowed_next_groups]=-1000+np.random.random(len(not_allowed_next_groups))\n        \n       # print(\"group_rq\")\n        \n    #    print(group_rq)\n\n        next_group=np.argmax(group_rq)\n\n     #   print(\"next_group = \",next_group)\n\n        assigned_groups[next_ind]=next_group\n\n    #    print(\"assigned_groups\")\n\n     #   print(assigned_groups)\n\n        remaining_group_slots[next_group]=remaining_group_slots[next_group]-1\n\n    #    print(\"remaining_group_slots\")\n\n     #   print(remaining_group_slots)\n\n    for sel_agent in np.arange(no_agents):\n        \n        all_agents[sel_agent].movement_group=int(assigned_groups[sel_agent])\n     \n    return(assigned_groups)\n\n##############################################################################################\n\ndef Set_New_Group_Goals(no_groups, canteen_prob, current_lunch_time, all_agents, no_teachers, no_in_each_age):\n    \n    all_group_goals=np.zeros(no_groups)\n    \n    for sel_group in np.arange(no_groups):\n        \n        if sel_group<no_groups/2:\n        \n            poss_goal_locations=all_agents[(no_teachers+1)].all_classrooms ##the goals are the classrooms\n        \n        else:\n            \n            older_agent=no_in_each_age[0]+no_teachers+1\n            \n            poss_goal_locations=all_agents[(older_agent+1)].all_classrooms ##the goals are the classrooms\n        \n        sel_goal=int(np.random.permutation(poss_goal_locations)[0]) ##select one at random\n\n        if current_lunch_time==1:\n            \n            r=np.random.random()\n        \n            if r<canteen_prob:\n                \n                sel_goal=all_agents[0].all_canteens[0]\n                \n\n        all_group_goals[sel_group]=sel_goal\n\n#    print(\"all_group_goals\")\n    \n #   print(all_group_goals)\n    \n    no_agents=len(all_agents)\n    \n    for sel_agent in np.arange(no_agents):\n        \n        all_agents[sel_agent].group_goals=all_group_goals\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "type": "text"}, {"name": "location_class.py", "content": "\n########################################################\n\n##Part A: load in the libraries and functions for running the code\n\n##libraries\n\nimport random\nfrom random import randint\nimport numpy as np\nimport csv\nimport time\nimport os\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\nimport networkx as nx\n\nfrom functools import partial\n\nimport scipy as sp\n\n##and the function files\n\n########################################################\n\n##the following code defines the location class, and all functions included involving the location\n\nclass Location():\n\n    ##the function to initialise all the values in the location\n\n    def __init__(self, sel_location, floor_width, floor_length, no_time_steps):\n\n        self.location_id=sel_location\n        row=int(sel_location/floor_width)\n        col=np.mod(sel_location,floor_width)\n        self.allowed_initial_location=0\n        self.possible_location=0\n        self.coords=[row,col]\n        self.no_agents_present=0\n        self.agents_in_location=0\n        self.locations_to_move_to=0\n        self.is_classroom=0\n        self.is_toilet=0\n        self.is_staff_room=0\n        self.is_canteen=0\n        self.classroom_year=0\n        \n        ##initialise the measures in each location\n        \n        self.mean_location_stress=0\n        self.mean_location_loneliness=0\n        \n        self.location_info=np.zeros([no_time_steps,2])\n\n    ############################################################\n\n    ##the function to check if a location is in the school map, and therefore can be moved to\n    \n    ##Function: Is_Possible_Location\n    \n    ##Inputs: school map\n    \n    ##Outputs: possible location\n    \n    ##What it does\n    \n    ##If a location is an allowed location, set the value of this location to 1.  If not, set it to zero.\n\n    def Is_Possible_Location(self,school_map):\n\n        self.possible_location=0 ##initially say that the location isn't possible\n\n        ##now check if the coordinates are set to one in school map\n\n        x_coord=self.coords[0]\n\n        y_coord=self.coords[1]\n\n        map_value=school_map[x_coord,y_coord]\n\n        if map_value==1:\n\n            self.possible_location=1 ##and set this as a possible location if they are\n\n\n    ############################################################\n\n    ##the function to allocate the room type\n    \n    def Allocate_Room_Type(self, poss_classrooms, non_classrooms):\n\n        location_id=self.location_id\n\n        self.is_classroom=0\n\n        poss_location=self.possible_location\n        \n        ##assign the selected rooms\n        \n        selected_toilets=non_classrooms[0:2]\n    \n#        print(\"selected_toilets\")\n        \n #       print(selected_toilets)\n    \n        ##select a canteen\n        \n        selected_canteen=np.array(non_classrooms[2]).astype(int)\n            \n  #      print(\"selected_canteen\")\n        \n   #     print(selected_canteen)\n            \n        ##select a staff-room\n        \n        selected_staffroom=np.array(non_classrooms[3]).astype(int)\n        \n    #    print(\"selected_staffroom\")\n        \n     #   print(selected_staffroom)\n\n        ##if the location is a possible location, then what kind of location is it?\n\n        if poss_location==1:\n            \n            for loc_tmp in poss_classrooms:\n               \n               if location_id==loc_tmp:\n                   \n                   self.is_classroom=1\n                   \n                   self.classroom_year=np.random.permutation(2)[0]+1\n                   \n            for loc_tmp in selected_toilets:\n               \n                if location_id==loc_tmp:\n                   \n                    self.is_toilet=1\n                    \n            loc_tmp=selected_canteen\n               \n            if location_id==loc_tmp:\n               \n                self.is_canteen=1\n                    \n            loc_tmp=selected_staffroom\n               \n            if location_id==loc_tmp:\n               \n                self.is_staff_room=1\n                   \n            \n            \n            \n\n\n\n\n\n\n\n\n\n\n    ############################################################\n\n    ##the function to set whether this location is a classroom\n    \n    ##Function: Is_Classroom\n    \n    ##Inputs: grid size\n    \n    ##Outputs: is classroom\n    \n    ##What it does\n    \n    ##If the location is on the top or bottom of the map, then it is assigned to be a classroom\n\n    def Is_Classroom(self,grid_size):\n\n        poss_location=self.possible_location\n\n        ##if the location is a possible location, then is the location on the top or bottom of the grid?\n\n        if poss_location==1:\n\n            coord=self.coords[1]\n\n            if coord==0:\n\n                self.is_classroom=1\n                \n            if coord==grid_size-1:\n\n                self.is_classroom=1\n                \n    ############################################################\n                \n    ##for an oblong grid, all locations are classrooms\n    \n    ##Function: Is_Classroom_Oblong\n    \n    ##Inputs: None\n    \n    ##Outputs: is classroom\n    \n    ##What it does\n    \n    ##For the oblong map, all locations are classrooms\n                \n    def Is_Classroom_Oblong(self):\n\n        self.is_classroom=1\n        \n    ############################################################\n\n    ##this function calculates the possible locations to move to, based on the allowed locations in the location grid matrix\n    \n    ##Function: Calc_Locations_To_Move_To\n    \n    ##Inputs: location grid matrix\n    \n    ##Outputs: Possible locations to move to\n    \n    ##What it does\n    \n    ##This function generates all the possible locations to move to from the focal location based on the location grid matrix.\n\n    def Calc_Locations_To_Move_To(self,location_grid_matrix):\n\n        grid_length=len(location_grid_matrix[0,0,:])\n\n        sel_location=self.location_id\n\n        coords_to_move_to=np.where(location_grid_matrix[sel_location,:,:]==1) ##which locations in the grid are set to one?\n\n        #print(coords_to_move_to)\n\n        self.locations_to_move_to=grid_length*coords_to_move_to[0]+coords_to_move_to[1] ##set all of these as the locations to move to\n\n        #if len(self.locations_to_move_to)>0:\n\n        #\tself.allowed_initial_location=1\n        \n    ############################################################\n\n    ##this function sets a location value to 1 if it is allowed to be an initial condition (which basically means it's at the top or bottom)\n    \n    ##Function: Allowed_Initial_Condition_Class\n    \n    ##Inputs: grid size\n    \n    ##Outputs: allowed initial condition\n    \n    ##What it does\n    \n    ##Sets the output to 1 if the location is an allowed initial condition.\n\n    def Allowed_Initial_Condition_Class(self,grid_size):\n\n        loc_col=np.mod(self.location_id,grid_size)\n\n        if loc_col==0:\n\n            self.allowed_initial_location=1\n\n        if loc_col==grid_size-1:\n\n            self.allowed_initial_location=1\n            \n    ############################################################\n            \n    ##for an oblong all locations can be an initial condition\n    \n    ##Function: Allowed_Initial_Condition_Class_Oblong\n    \n    ##Inputs: None\n    \n    ##Outputs: allowed initial condition\n    \n    ##What it does\n    \n    ##Sets the output to 1 if the location is an allowed initial condition in the oblong map (which for is true for all locations in the oblong).\n            \n    def Allowed_Initial_Condition_Class_Oblong(self):\n\n        self.allowed_initial_location=1\n        \n    ############################################################    \n        \n    ##this function calculates the number agents in the location in this time step\n    \n    ##Function: Calc_No_Agents_In_Location\n    \n    ##Inputs: all agents\n    \n    ##Outputs: no. of agents present\n    \n    ##What it does\n    \n    ##Calculates the number of agents present in the location.\n        \n    def Calc_No_Agents_In_Location(self,all_agents):\n\n        no_agents=len(all_agents) \n\n        self.no_agents_present=0 ##initialise that there are no agents present\n\n        for sel_agent in np.arange(no_agents): ##for each agent, check their location\n\n            agent_location=all_agents[sel_agent].current_location\n\n            if agent_location==self.location_id: ##if the agent's location matches the current location, add this to the total\n\n                self.no_agents_present=self.no_agents_present+1\n                \n    ############################################################\n\n    ##this function currently checks which agents are in the location in this time step\n    \n    ##Function: Which_Agents_In_Location\n    \n    ##Inputs: all agents\n    \n    ##Outputs: the agent id's present in the location\n    \n    ##What it does\n    \n    ##For a given location, this returns the agent id's of those present. \n\n    def Which_Agents_In_Location(self,all_agents):\n\n        self.agents_in_location=np.zeros(self.no_agents_present) ##initialise a vector to record them\n\n        no_agents=len(all_agents)\n\n        agent_count=0\n\n        for sel_agent in np.arange(no_agents): ##for all the agents...\n\n            agent_location=all_agents[sel_agent].current_location\n\n            if agent_location==self.location_id: ##if the agent's location matches the selected location, add the agent\n\n                self.agents_in_location[agent_count]=sel_agent\n\n                agent_count=agent_count+1\n\n\n    ############################################################\n\n    ##this function currently checks which agent types are in the location in this time step\n    \n    ##Function: Calc_No_Agent_Types_In_Location\n    \n    ##Inputs: all agents\n    \n    ##Outputs: no. agent types in the location\n    \n    ##What it does\n    \n    ##For a given location, this function tells you how many teachers and students are present.\n        \n    def Calc_No_Agent_Types_In_Location(self,all_agents):\n\n        no_agents=len(all_agents)\n\n        self.no_agent_types_present=np.zeros(3) ##initialise the empty vector for each possible agent type\n\n        for sel_agent in np.arange(no_agents): ##for all the agents...\n\n            agent_location=all_agents[sel_agent].current_location\n\n            if agent_location==self.location_id: ##if the agent's location matches the selected location, add the agents type\n\n                agent_type=all_agents[sel_agent].agent_type\n\n                self.no_agent_types_present[int(agent_type)]=self.no_agent_types_present[int(agent_type)]+1\n        \n    ############################################################\n        \n    ##this function currently checks the status of each agent in the location in this time step\n    \n    ##Function: Calc_Agent_Status_In_Location\n    \n    ##Inputs: all agents\n    \n    ##Outputs: agent status\n    \n    ##What it does\n    \n    ##This function records the status of every agent in the current location.\n        \n    def Calc_Agent_Status_In_Location(self,all_agents):\n\n        no_agents=len(all_agents)\n\n        self.agent_status=np.zeros(self.no_agents_present) ##initialise an empty vector for the status of all of the agents in the location\n\n        status_count=0 ##keep track of which agent in the location we're checking\n\n        for sel_agent in np.arange(no_agents): ##for all the agents...\n\n            agent_location=all_agents[sel_agent].current_location\n\n            if agent_location==self.location_id: ##if the agent's location matches the selected location, add the agents status\n\n                self.agent_status[status_count]=all_agents[sel_agent].status\n                \n                status_count=status_count+1\n\n\n#################################################################\n\n    ##function: calculate the mean stress and loneliness in the location\n\n    def Calc_Agent_Stress_And_Loneliness_In_Location(self,all_agents):\n\n        no_agents=len(all_agents)\n\n        location_agent_stress_and_loneliness=np.zeros([self.no_agents_present, 2]) ##initialise an empty vector for the status of all of the agents in the location\n\n        agent_count=0 ##keep track of which agent in the location we're checking\n        \n        mean_stress_loneliness=[0, 0]\n\n        for sel_agent in np.arange(no_agents): ##for all the agents...\n\n            agent_location=all_agents[sel_agent].current_location\n\n            if agent_location==self.location_id: ##if the agent's location matches the selected location, add the agents status\n\n                location_agent_stress_and_loneliness[agent_count, 0]=all_agents[sel_agent].stress\n                \n                location_agent_stress_and_loneliness[agent_count, 1]=all_agents[sel_agent].rq\n                \n                agent_count=agent_count+1\n                \n#        print(\"location_agent_stress_and_loneliness\")\n        \n #       print(location_agent_stress_and_loneliness)\n                \n        if self.no_agents_present>0:\n            \n            mean_stress_loneliness=np.mean(location_agent_stress_and_loneliness, axis=0)\n\n #       print(\"mean_stress_loneliness\")\n        \n #       print(mean_stress_loneliness)\n\n        self.mean_location_stress=mean_stress_loneliness[0]\n        self.mean_location_loneliness=mean_stress_loneliness[1]\n\n\n    ##################################\n    \n    ##this function records all of the necessary information in this time step for this agent\n \n    def Record_Location_Info(self,time):\n\n        self.location_info[time,0]=self.mean_location_stress\n\n        self.location_info[time,1]=self.mean_location_loneliness\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "type": "text"}, {"name": "run_single_model_function.py", "content": "########################################################\n\n##Part A: load in the libraries and functions for running the code\n\n##libraries\n\nimport random\nfrom random import randint\nimport numpy as np\nimport csv\nimport time\nimport os\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\nimport networkx as nx\n\nfrom functools import partial\n\nimport scipy as sp\n\nimport pandas as pd\n\n##and the function files\n\nfrom agent_class import Agent\nfrom location_class import Location\n\nfrom general_functions import Generate_Oblong_Location_Grid\nfrom general_functions import Generate_Oblong_Graph\nfrom general_functions import Generate_Corridor\nfrom general_functions import Generate_Floor_Corridor\nfrom general_functions import Generate_Two_Floor_School\nfrom general_functions import Generate_Two_Floor_School_Shut_Top_Floor\nfrom general_functions import Generate_Two_Floor_School_Shut_Bottom_Floor\n\nfrom general_functions import Update_Location_Graph\n\nfrom general_functions import Assign_Groups\n\nfrom general_functions import Set_New_Group_Goals\n\n#from plot_output_functions import Plot_Output\n\n#######################################################################################################################################################\n\n##function to run a single run of the model\n\ndef Run_The_Model_Once(all_calibrated_inputs, all_inputs_set_through_data, all_technical_inputs):\n    \n    ##set parameters\n    \n    plot_type=all_technical_inputs[0]\n    map_type=all_technical_inputs[1]\n    floor_width=all_technical_inputs[2]\n    floor_length=all_technical_inputs[3]\n    stair_case_width=all_technical_inputs[4]\n    corridor_width=all_technical_inputs[5]\n    no_time_steps=all_technical_inputs[6]\n    no_students=all_technical_inputs[7]\n    no_teachers=all_technical_inputs[8]\n    no_bullies=all_technical_inputs[9]\n    inc_science_perspective=all_technical_inputs[10]\n    inc_walking_perspective=all_technical_inputs[11]\n    inc_yais_perspective=all_technical_inputs[12]\n    inc_teacher_perspective=all_technical_inputs[13]\n    no_classes=all_technical_inputs[14]\n    \n    moving_times=all_technical_inputs[15]\n    move_with_friends=all_technical_inputs[16]\n    lunch_times=all_technical_inputs[17]\n    \n    no_groups=all_technical_inputs[18]\n    \n    class_prob_dist=all_technical_inputs[19]\n    \n    use_emp_networks=all_technical_inputs[20]\n    \n    ##parameters set by the data\n    \n    toilet_prob=all_inputs_set_through_data[0]\n    canteen_prob=all_inputs_set_through_data[1]\n    \n    ##parameters to be calibrated\n    \n    stress_decay=all_calibrated_inputs[0]\n    status_threshold=all_calibrated_inputs[1]\n    increase_in_stress_due_to_neg_int=all_calibrated_inputs[2]\n    decrease_in_stress_due_to_pos_int=all_calibrated_inputs[3]\n    rq_decrease_through_bullying=all_calibrated_inputs[4]\n    rq_increase_through_support=all_calibrated_inputs[5]\n    \n    crowded_threshold=all_calibrated_inputs[6]\n    crowded_stress=all_calibrated_inputs[7]\n    journey_stress=all_calibrated_inputs[8]\n    stress_bully_scale=all_calibrated_inputs[9]\n    \n    stress_through_class_interaction=all_calibrated_inputs[10]\n    prob_teacher_moving=all_calibrated_inputs[11]\n    status_increase=all_calibrated_inputs[12]\n    status_decrease=all_calibrated_inputs[13]\n    \n    mean_time_stress=all_calibrated_inputs[14]\n    mean_room_stress=all_calibrated_inputs[15]\n    \n    prob_follow_group=all_calibrated_inputs[16]\n    \n    #############\n    \n    ##load in the empirical networks\n    \n    emp_networks=pd.read_csv(\"C:/Users/jma53d/OneDrive - University of Glasgow/WP3 - ABM/simulation/RQ_inputs.csv\")\n\n    print(\"emp_networks\")\n\n    print(emp_networks)\n    \n    ##Part xxx: initialise the locations\n\n    grid_size=0\n    \n    if map_type==\"grid\":\n\n        grid_size=floor_width*floor_length ##size of the grid \n        \n        no_locations=floor_width*floor_length ##one location for each grid point\n\n    if map_type==\"school\":\n\n        grid_width=2*floor_width+stair_case_width ##width of the grid\n        \n        grid_length=floor_width ##length of the grid\n\n        no_locations=grid_width*grid_length ##one location for each grid point\n\n    all_locations=[] ##initialise the locations\n    \n#        if input.update_geography()==\"1\":\n    \n    \n    \n    for sel_location in np.arange(no_locations): ##and then initialise them\n    \n        all_locations.append(Location(sel_location, floor_width, floor_length, no_time_steps))\n \n    ##commented code to check that it worked\n \n#    sel_location=np.random.randint(no_locations)\n    \n#    print(\"Random location ID\")\n    \n#    print(all_locations[sel_location].location_id)\n    \n#    print(\"Random location coordinate\")\n    \n#    print(all_locations[sel_location].coords)\n    \n    ######################\n    \n    ##Part xxx: generate the grid to look like a rectangle or the map of the school\n    \n        ##set up the information for each agent\n    \n    if map_type==\"grid\":\n    \n        ##update the allowed locations and the graph connecting them based on the school map\n        \n        location_grid_matrix=Generate_Oblong_Location_Grid(floor_width,floor_length,all_locations)\n        \n        ##display it\n        \n#        print(\"location_grid_matrix\")\n        \n #       print(location_grid_matrix)\n        \n        ##generate the graph of connected locations\n        \n        G=Generate_Oblong_Graph(floor_width,floor_length,location_grid_matrix,all_locations)\n        \n#        G_top_closed=Generate_Oblong_Graph(floor_width,floor_length,location_grid_matrix,all_locations)\n        \n #       G_bottom_closed=Generate_Oblong_Graph(floor_width,floor_length,location_grid_matrix,all_locations)\n\n\n    if map_type==\"school\":\n\n        corridors_open=0\n        \n        G=Update_Location_Graph(all_locations,corridors_open,floor_width,stair_case_width,corridor_width)\n                \n        corridors_open=1\n                \n#        G_top_closed=Update_Location_Graph(all_locations,corridors_open,floor_width,stair_case_width,corridor_width)\n        \n        corridors_open=2\n                \n #       G_bottom_closed=Update_Location_Graph(all_locations,corridors_open,floor_width,stair_case_width,corridor_width)\n\n                    \n    #########################\n    \n    ##Part xxx: initialise the agents\n                    \n    no_agents=no_students+no_teachers\n    \n    no_locations=len(all_locations)\n        \n    ##assign agents to be bullies and teachers\n\n    ##type 0 = student\n    ##type 1 = bully\n    ##type 2 = teacher\n\n    initial_agent_type_ordered=np.zeros(no_agents)\n\n    initial_agent_type_ordered[0:no_teachers]=2\n\n    initial_agent_type_ordered[no_teachers:(no_teachers+no_bullies)]=1\n\n    #print(\"initial_agent_type_ordered\")\n\n    #print(initial_agent_type_ordered)\n\n    initial_agent_types=initial_agent_type_ordered#np.random.permutation(initial_agent_type_ordered)\n\n    #print(\"initial_agent_type\")\n\n    #print(initial_agent_types)#\n    \n    #########\n    \n    ##assign ages to each agent\n    \n    age_category=np.zeros(no_agents)\n    \n    if use_emp_networks==1:\n    \n        no_in_each_age=[171, 205]\n        \n    else:\n        \n        no_in_each_age_tmp=int((no_agents-no_teachers)/2)\n        \n        no_in_each_age=np.zeros(2).astype(int)\n        \n        no_in_each_age[0]=int(no_in_each_age_tmp)\n        \n        no_in_each_age[1]=int(no_in_each_age_tmp)\n        \n    age_category[no_teachers:(no_in_each_age[0]+no_teachers)]=1\n    \n    age_category[(no_in_each_age[0]+no_teachers+1):no_agents]=2\n    \n    \n        \n        \n    \n    #########\n    \n    all_agents=[] ##initialise the agents\n\n    ##and then generate them\n\n    for sel_agent in np.arange(no_agents):\n\n        all_agents.append(Agent(sel_agent, no_time_steps, age_category))\n\n    for sel_agent in np.arange(no_agents):\n\n        all_agents[sel_agent].Record_All_Location_Types(all_locations) ##which are the classrooms\n\n        all_agents[sel_agent].Initialise_Agent_Type(initial_agent_types) ##what type are they\n        \n        all_agents[sel_agent].Initialise_Agent_Class(no_classes,class_prob_dist) ##what class are they?\n\n    ##permute all the classrooms so that we can assign them to teachers\n\n    poss_classrooms=all_agents[0].all_classrooms\n\n#    print(\"poss_classrooms\")\n    \n #   print(poss_classrooms)\n\n    assigned_teacher_classrooms=np.random.permutation(poss_classrooms)\n\n  #  print(\"assigned_teacher_classrooms\")\n    \n   # print(assigned_teacher_classrooms)\n\n    for sel_agent in np.arange(no_agents):\n\n        all_agents[sel_agent].Initialise_RQ(all_agents, emp_networks, initial_agent_types, no_teachers, use_emp_networks) ##initialise the social network\n        \n    S2_agent_ids=np.where(age_category==1)[0]\n    \n    S4_agent_ids=np.where(age_category==2)[0]\n    \n    print(\"S4_agents\")\n    \n    print(S4_agent_ids)\n        \n    S2_agents=[]\n        \n    for i in S2_agent_ids:\n        \n            S2_agents.append(all_agents[i])\n            \n    S4_agents=[]\n        \n    for i in S4_agent_ids:\n        \n            S4_agents.append(all_agents[i])\n        \n    assigned_groups=Assign_Groups(S2_agents, int(no_groups/2))\n    \n    assigned_groups=Assign_Groups(S4_agents, int(no_groups/2))\n\n    print(\"assigned_groups\")\n\n    print(assigned_groups)\n    \n    for i in S4_agent_ids:\n        \n            all_agents[i].movement_group=all_agents[i].movement_group+int(no_groups/2)\n\n#    print(\"Example groups\")\n    \n #   print(all_agents[50].movement_group)\n    \n  #  print(all_agents[250].movement_group)\n\n    Set_New_Group_Goals(no_groups, canteen_prob, 0, all_agents, no_teachers, no_in_each_age)\n\n    for sel_agent in np.arange(no_agents):\n\n        all_agents[sel_agent].Initialise_Location(all_locations,assigned_teacher_classrooms, prob_follow_group) ##where do they start?\n\n        all_agents[sel_agent].Initialise_Agent_Location_Time_Stress(all_locations,no_time_steps, mean_time_stress, mean_room_stress, inc_walking_perspective) ##how stressed are they in their initial location\n\n        all_agents[sel_agent].Record_Agent_Info(0) ##save this initial information\n\n        \n #   print(\"All classrooms\")\n\n  #  print(all_agents[0].all_classrooms)\n        \n    ##also initialise the information in the locations\n        \n    for sel_location in np.arange(no_locations):\n\n            all_locations[sel_location].Calc_No_Agents_In_Location(all_agents) ##how many agents are in the location?\n            \n            all_locations[sel_location].Calc_No_Agent_Types_In_Location(all_agents) ##how many agents of each type are there?\n            \n            all_locations[sel_location].Calc_Agent_Status_In_Location(all_agents) ##what is the status of all the agents in that location?\n            \n    ##finally, initialise the next goal location of the agent\n            \n    for sel_agent in np.arange(no_agents):\n\n        ################\n\n        ##movement functions\n\n        all_agents[sel_agent].Set_New_Goal_Class(prob_teacher_moving, canteen_prob, 0, prob_follow_group) ##where is the new goal?\n\n        all_agents[sel_agent].Ideal_Goal_Length(all_locations,G) ##how long should it take?\n\n    #    print(\"goal length = \",all_agents[sel_agent].ideal_goal_length)\n\n        ################\n\n        ##stress functions\n\n#        all_agents[sel_agent].Decide_If_Stressed_Due_To_Time(all_locations,status_threshold,0)\n\n #       all_agents[sel_agent].Decide_If_Stressed_Due_To_Location(all_locations,status_threshold,0)\n\n\n        ################\n\n        ##record the info\n\n        all_agents[sel_agent].Record_Agent_Info(0)\n\n\n    ###########################################\n    \n    ##Part xxx: run the model for a set amount of time\n\n    ##and now move the agent around\n\n    G_current=G ##set the current map of the school\n    \n    sel_moving_time=0\n    \n    first_moving_time=moving_times[sel_moving_time]\n    \n    no_moving_times=len(moving_times)\n    \n    for time in np.arange(1,no_time_steps): ##run through all the time steps\n\n#        if np.mod(int((time/no_time_steps)*100),10)==0:\n\n        current_moving_time=moving_times[sel_moving_time]\n        \n        current_lunch_time=lunch_times[sel_moving_time] ##is it currently lunch time?\n        \n        print(\"%age done = \",np.round(time/no_time_steps*100),\"%\", end=\"\\r\")\n\n        ################\n\n        ##movement functions\n\n        ##and run through the actions of the agent\n        \n        ##decide if an agent should go to the toilet\n            \n        for sel_agent in np.arange(no_agents):\n\n            agent_type=all_agents[sel_agent].agent_type ##agent type\n            \n            if agent_type==1:\n            \n                r=np.random.random()\n                \n                if r<toilet_prob: ##...and by chance they don't move\n                    \n                    all_agents[sel_agent].Set_New_Goal_Toilet()\n\n        ##initially don't move the agent for the first ten time steps, but after that move them every 20\n        \n        if time>first_moving_time:\n        \n            ##if the time is larger than the first moving time, move the agent\n\n            for sel_agent in np.arange(no_agents):\n\n                all_agents[sel_agent].Move_Agent(all_locations,G_current)\n            \n        ##move the agent every set time steps, and reset the goal and the ideal goal length\n\n        if time==current_moving_time:\n        \n            if sel_moving_time<no_moving_times-1:\n        \n                sel_moving_time=sel_moving_time+1\n            \n            current_moving_time=moving_times[sel_moving_time]\n\n            Set_New_Group_Goals(no_groups, canteen_prob, current_lunch_time, all_agents, no_teachers, no_in_each_age)\n\n            for sel_agent in np.arange(no_agents):\n\n                all_agents[sel_agent].Set_New_Goal_Class(prob_teacher_moving, canteen_prob, current_lunch_time, prob_follow_group)\n\n                all_agents[sel_agent].Ideal_Goal_Length(all_locations,G)\n\n\n\n        ##update the location information after these movements\n\n        for sel_location in np.arange(no_locations):\n\n            all_locations[sel_location].Calc_No_Agents_In_Location(all_agents)\n\n            all_locations[sel_location].Calc_No_Agent_Types_In_Location(all_agents)\n\n            all_locations[sel_location].Calc_Agent_Status_In_Location(all_agents)\n\n            all_locations[sel_location].Which_Agents_In_Location(all_agents)\n            \n            all_locations[sel_location].Calc_Agent_Stress_And_Loneliness_In_Location(all_agents)\n            \n            all_locations[sel_location].Record_Location_Info(time)\n\n        ################\n        \n        ##decide which interactions occur\n\n        ##negative interactions\n\n        for sel_agent in np.arange(no_agents):\n\n            all_agents[sel_agent].Decide_Negative_Interaction(all_agents,all_locations,status_threshold,stress_bully_scale)\n\n            all_agents[sel_agent].Decide_Negative_Class_Interaction(all_agents,all_locations)\n\n        ##################\n\n        ##positive interactions (possibly in response to bullying)\n\n        for sel_agent in np.arange(no_agents):\n\n            all_agents[sel_agent].Decide_Positive_Interaction(all_agents,all_locations)\n\n        ################\n\n        ##update stress, rq and status based on which perspectives are included\n        \n        if inc_science_perspective==1:\n\n            for sel_agent in np.arange(no_agents):\n\n                all_agents[sel_agent].Update_Stress_Due_To_Interactions(all_locations,all_agents,increase_in_stress_due_to_neg_int,decrease_in_stress_due_to_pos_int)\n\n                all_agents[sel_agent].Update_Status(status_increase,status_decrease)\n\n                all_agents[sel_agent].Update_Loneliness_Calc()\n\n                all_agents[sel_agent].Update_All_RQ_Based_On_Interaction(rq_decrease_through_bullying,rq_increase_through_support)\n\n        if inc_walking_perspective==1 or inc_yais_perspective==1:\n\n            for sel_agent in np.arange(no_agents):\n                \n                all_agents[sel_agent].Decide_If_Stressed_Due_To_Time(all_locations,status_threshold,time)\n\n                all_agents[sel_agent].Decide_If_Stressed_Due_To_Location(all_locations,status_threshold,time)\n\n                all_agents[sel_agent].Decide_If_Stressed_Due_To_Crowdedness(all_locations,crowded_threshold,crowded_stress)\n                \n        if inc_yais_perspective==1:\n\n            for sel_agent in np.arange(no_agents):\n\n                #print(\"Journey time = \",all_agents[sel_agent].journey_time,\", Ideal journey time = \",all_agents[sel_agent].ideal_goal_length)\n                \n                all_agents[sel_agent].Decide_If_Stressed_Due_To_Delay(journey_stress)\n\n            \n        if inc_teacher_perspective==1:\n        \n            for sel_agent in np.arange(no_agents):\n\n                all_agents[sel_agent].Update_Stress_Due_To_Class_Interactions(stress_through_class_interaction,decrease_in_stress_due_to_pos_int)\n            \n        for sel_agent in np.arange(no_agents):\n            \n            all_agents[sel_agent].Decay_Stress(stress_decay, time)\n            \n            all_agents[sel_agent].Calc_Network_Degree()\n\n        ################\n\n        ##record the info\n\n        for sel_agent in np.arange(no_agents):\n\n            all_agents[sel_agent].Record_Agent_Info(time)\n                \n        all_outputs=[all_agents, all_locations]\n                \n    return(all_outputs)\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n", "type": "text"}]